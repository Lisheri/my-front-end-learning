---
title: 函数组合
date: 2020-04-15
tags:
 - 函数式编程
categories:
 -  函数式编程
---

## 函数的组合

使用纯函数和柯里化很容易写出洋葱代码，就是一层一层包裹的代码 `g(f(h(x)))`

因此我们需要组合, 函数组合可以让我们把细粒度的函数重新组合生成一个新的函数

### 管道

管道其实就是一个映射函数, 也就是纯函数

但是当管道过大的情况下，调试会变得非常困难，中间出了问题不方便调试，因此我们将一个长管道(大段函数)拆分为一个个更细粒度的函数。

这些函数一般是放在一个队列中，从左往右进入，从右往左执行(先进先出)。

伪代码表示:

```
fn = compose(f1, f2, f3);
b = fn(a);
```

### 函数组合

如果一个函数要经过多个函数处理才能得到最终值, 这个时候可以把中间过程的函数合并为一个函数。

函数就像是一个管道，拆分的函数就像是拆开了这个管道, 让输入数据穿过多个管道得到最终结果。

函数组合默认从右向左执行(执行队列);

```javaScript
// 模拟一个双函数组合
function compose(f, g) {
    return function (x) {
        return f(g(x));
    }
}

// 使用上述双函数组合函数
const reverse = (arr) => arr.reverse();
const first = (arr) => arr[0];

const last = compose(first, reverse);

console.info(lase([1 ,2, 3, 4,]))
```

实际上还是洋葱代码，但是这一层包裹进了compose函数中，外部已经看不到了。

`lodash 提供了一个 flowRight方法可以任意组合函数`;

### 结合律

所谓结合律就是在总量一样的情况下，任意先组合几个函数，但函数执行顺序和函数量相同，最终组合出来的函数相同(其实就是数学中加乘法的结合律)

如: `compose(f, compose(g, h)) === compose(compose(f, g), h)`


### 调试组合函数

由于组合函数是一个执行队列，先进先出，表现出为从右往左执行，因此可以在任意函数执行后, 传入一个打印参数并返回参数的日志函数

可以在任意需要的位置插入日志函数

```javaScript
// 日志函数
const log = (r) => {
    console.info(r);
    return r;
}
```

但是这样的日志函数打印不够清晰，如果多段插入，会造成混淆。

因此可以改造一下

```javaScript
const trace = _.curry((tag, v) => {
    console.info(tag, v);
    return v;
})
```

### lodash-fp模块

lodash的fp模块提供了实用的对函数式编程友好的方法

提供了不可变auto-curried(自动柯里化) iteratee-first(函数优先) data-last(数据滞后) 方法

```javaScript
fp.map(fp.toUpper, ['a', 'b', 'c', 'd'])
fp.map(fp.toUpper)(['a', 'b', 'c', 'd'])

// * 上述执行结果相同, 因为fp模块下的函数会自动柯里化, 优先执行回调函数, 利用返回的函数去接收数据
```
### Point Free

是一种编程风格，我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数, 只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数。

+ 不需要指明处理的数据
+ 只需要合成运算过程
+ 需要定义一些辅助的基本运算函数

之前在使用函数组合去处理问题的时候，实际上就是一种 Point Free模式

没有指明要处理的数据，而是通过一些辅助函数去组合一个处理数据的函数

`const f = fp.flowRight(fp.join('-'), fp.map(_.toLower), fp.split(' '))`

因此，Point Free的实现方式就是函数的组合





