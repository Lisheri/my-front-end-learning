---
title: Vue3ÁªÑ‰ª∂Ê∏≤Êüì - ÂÆåÊï¥ÁöÑDOM Diff ÊµÅÁ®ã(‰∏Ä)
date: 2022-09-20
tags:
    - vue
categories:
    - vue3Ê∫êÁ†Å
---

# Vue3ÁªÑ‰ª∂Ê∏≤Êüì - ÂÆåÊï¥ÁöÑDOM Diff ÊµÅÁ®ã(‰∏Ä)

+ VueÁªÑ‰ª∂ÁöÑÊ∏≤ÊüìÊµÅÁ®ã, Êú¨Ë¥®‰∏äÂ∞±ÊòØÊääÂêÑÁßçÁ±ªÂûãÁöÑvnodeÊ∏≤Êüì‰∏∫ÁúüÂÆûDOM
+ ÁªÑ‰ª∂ÊòØÁî±Ê®°Êùø„ÄÅÁªÑ‰ª∂ÊèèËø∞ÂØπË±°ÂíåÊï∞ÊçÆÊûÑÊàêÁöÑ, Êï∞ÊçÆÁöÑÂèòÂåñ‰ºöÂΩ±ÂìçÁªÑ‰ª∂ÁöÑÂèòÂåñ
  - ÁªÑ‰ª∂ÁöÑÊ∏≤ÊüìËøáÁ®ã‰∏≠ÂàõÂª∫‰∫Ü‰∏Ä‰∏™Â∏¶ÂâØ‰ΩúÁî®ÁöÑÊ∏≤ÊüìÂáΩÊï∞
  - ÂΩìÊï∞ÊçÆÂèòÂåñÁöÑÊó∂ÂÄôÂ∞±‰ºöÊâßË°åËøô‰∏™Ê∏≤ÊüìÂáΩÊï∞Êù•Ëß¶ÂèëÁªÑ‰ª∂Êõ¥Êñ∞


## Â∏¶ÂâØ‰ΩúÁî®Ê∏≤ÊüìÂáΩÊï∞Êõ¥Êñ∞ÁªÑ‰ª∂ÁöÑËøáÁ®ã

‰ª•‰∏ãÊòØÂâØ‰ΩúÁî®Ê∏≤ÊüìÂáΩÊï∞ setupRenderEffect ÁöÑÂÆûÁé∞

```ts
const setupRenderEffect: SetupRenderEffectFn = (
    instance,
    initialVNode,
    container,
    anchor,
    parentSuspense,
    isSVG,
    optimized
  ) => {
    // create reactive effect for rendering
    // ÂàõÂª∫ÂìçÂ∫îÂºèÁöÑÂâØ‰ΩúÁî®Ê∏≤ÊüìÂáΩÊï∞
    instance.update = effect(function componentEffect() {
      if (!instance.isMounted) {
        // ÂàõÂª∫ÁªÑ‰ª∂
      } else {
        // Êõ¥Êñ∞ÁªÑ‰ª∂
        // updateComponent
        // This is triggered by mutation of component's own state (next: null)
        // OR parent calling processComponent (next: VNode)
        let { next, bu, u, parent, vnode } = instance
        let originNext = next
        let vnodeHook: VNodeHook | null | undefined
        if (__DEV__) {
          pushWarningContext(next || instance.vnode)
        }

        // nextË°®Á§∫Êñ∞ÁöÑÁªÑ‰ª∂VNode
        // ËøôÈáåÂÖàÂà§Êñ≠Êñ∞ÁöÑÁªÑ‰ª∂ÂÆû‰æã‰∏≠ÊòØÂê¶ÊúâÊñ∞ÁöÑÁªÑ‰ª∂VNode(ËøôÈáåËÆæËÆ°‰∏Ä‰∏™ÁªÑ‰ª∂Êõ¥Êñ∞ÁöÑÈÄªËæë, Á®çÂêé‰ºöËØ¥, Ëøô‰πüÊòØÈúÄË¶ÅÂà§Êñ≠ÁöÑÂéüÂõ†)
        if (next) {
          // ÊúâÂàôÊõ¥Êñ∞ÁªÑ‰ª∂VNode
          next.el = vnode.el
          updateComponentPreRender(instance, next, optimized)
        } else {
          // Ê≤°ÊúâÂàônextÊåáÂêë‰πãÂâçÁöÑÁªÑ‰ª∂VNode
          next = vnode
        }

        // beforeUpdate hook
        if (bu) {
          invokeArrayFns(bu)
        }
        // onVnodeBeforeUpdate
        if ((vnodeHook = next.props && next.props.onVnodeBeforeUpdate)) {
          invokeVNodeHook(vnodeHook, parent, next, vnode)
        }

        // render
        if (__DEV__) {
          startMeasure(instance, `render`)
        }
        // Ê∏≤ÊüìÊñ∞ÁöÑÂ≠êÊ†ëvnode
        const nextTree = renderComponentRoot(instance)
        if (__DEV__) {
          endMeasure(instance, `render`)
        }
        // ÁºìÂ≠òÊóßÁöÑÂ≠êÊ†ëvnode
        const prevTree = instance.subTree
        // Êõ¥Êñ∞Â≠êÊ†ëvnode
        instance.subTree = nextTree

        if (__DEV__) {
          startMeasure(instance, `patch`)
        }
        // ÁªÑ‰ª∂Êõ¥Êñ∞Ê†∏ÂøÉÈÄªËæë, Ê†πÊçÆÊñ∞ÊóßÂ≠êÊ†ëvnodeÂÅöpatch
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          // Â¶ÇÊûúÂú®teleportÁªÑ‰ª∂‰∏≠Áà∂ËäÇÁÇπÂèØËÉΩÂ∑≤ÁªèÊîπÂèò, ÊâÄ‰ª•ÂÆπÂô®Áõ¥Êé•ÊâæÊóßÊ†ëDOMÂÖÉÁ¥†ÁöÑÁà∂ËäÇÁÇπ
          hostParentNode(prevTree.el!)!,
          // anchor may have changed if it's in a fragment
          // ÂèÇËÄÉËäÇÁÇπ(ÈîöÁÇπ)Âú®fragmentÁöÑÊÉÖÂÜµÂèØËÉΩÊîπÂèò, ÊâÄ‰ª•Áõ¥Êé•ÊâæÊóßÊ†ëDOMÂÖÉÁ¥†ÁöÑ‰∏ã‰∏Ä‰∏™ËäÇÁÇπ
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        )
        if (__DEV__) {
          endMeasure(instance, `patch`)
        }
        // ÁºìÂ≠òÊõ¥Êñ∞ÂêéÁöÑDOMËäÇÁÇπ
        next.el = nextTree.el
        if (originNext === null) {
          // self-triggered update. In case of HOC, update parent component
          // vnode el. HOC is indicated by parent instance's subTree pointing
          // to child component's vnode
          updateHOCHostEl(instance, nextTree.el)
        }
        // updated hook
        if (u) {
          queuePostRenderEffect(u, parentSuspense)
        }
        // onVnodeUpdated
        if ((vnodeHook = next.props && next.props.onVnodeUpdated)) {
          queuePostRenderEffect(() => {
            invokeVNodeHook(vnodeHook!, parent, next!, vnode)
          }, parentSuspense)
        }

        if (__DEV__ || __FEATURE_PROD_DEVTOOLS__) {
          devtoolsComponentUpdated(instance)
        }

        if (__DEV__) {
          popWarningContext()
        }
      }
    }, __DEV__ ? createDevEffectOptions(instance) : prodEffectOptions)
  }
```

ÂèØ‰ª•ÁúãÂà∞Êõ¥Êñ∞ÁªÑ‰ª∂‰∏ªË¶ÅÂÅö‰∏â‰ª∂‰∫ãÊÉÖ:

1. Êõ¥Êñ∞ÁªÑ‰ª∂VNodeËäÇÁÇπ
  + ËøôÈáå‰ºöÊúâ‰∏Ä‰∏™Êù°‰ª∂Âà§Êñ≠, Âà§Êñ≠Êñ∞ÁöÑÁªÑ‰ª∂ÂÆû‰æã‰∏≠ÊòØÂê¶‰ºöÊúâÊñ∞ÁöÑÁªÑ‰ª∂VNode, Áî® next Ë°®Á§∫
  + ÊúâÂàôÊõ¥Êñ∞ÁªÑ‰ª∂VNode
  + Ê≤°ÊúâÂàônextÊåáÂêë‰πãÂâçÁöÑÁªÑ‰ª∂VNode
  + ÂÖ≥‰∫éÈúÄË¶ÅÊù°‰ª∂Âà§Êñ≠ÁöÑÂéüÂõ†, ËøôÈáåÊ∂âÂèä‰∏Ä‰∏™ÁªÑ‰ª∂Êõ¥Êñ∞Á≠ñÁï•ÁöÑÈÄªËæë, ÂêéÁª≠ÁªÜüîê 
2. Ê∏≤ÊüìÊñ∞Â≠êÊ†ëvnode(subTree)
  + Âõ†‰∏∫Ê∏≤ÊüìÂèëÁîü‰∫ÜÂèòÂåñ, Ê®°Êùø‰πüÂíåÊï∞ÊçÆÁõ∏ÂÖ≥, ÊâÄ‰ª•Ê∏≤ÊüìÁîüÊàêÁöÑÂ≠êÊ†ëvnode‰πü‰ºöÂèëÁîüÁõ∏Â∫îÁöÑÂèòÂåñ
  + Ë∞ÉÁî® renderComponentRoot Ê∏≤ÊüìÊñ∞ÁöÑÂ≠êÊ†ëvnode
  + ÁÑ∂ÂêéÁºìÂ≠òÊóßÁöÑÂ≠êÊ†ëvndoe
  + ÁºìÂ≠òÂÆåÊØïÂêé, Â∞ÜÊñ∞ÁöÑÂ≠êÊ†ëvnodeÊåáÂêë instance.subTree, Êõ¥Êñ∞Â≠êÊ†ëvnode
3. Ê†πÊçÆÊñ∞ÊóßÂ≠êÊ†ëVNodeÊâßË°å[patch](/blogs/vue3-resource/core/4.html#patchÊõ¥Êñ∞ÈÄªËæë)ÈÄªËæë
  + ÁªÑ‰ª∂Êõ¥Êñ∞ÁöÑÊ†∏ÂøÉÈÄªËæë
  + Áî®Êù•ÊâæÂá∫Â≠êÊ†ëvnodeÁöÑ‰∏çÂêå, Âπ∂ÊâæÂá∫‰∏ÄÁßçÂêàÈÄÇÁöÑÊñπÂºèÊõ¥Êñ∞dom 


## patchÊõ¥Êñ∞ÈÄªËæë

Ê†πÊçÆpatchÁöÑÈÄªËæëÂèØ‰ª•ÁúãÂà∞

1. È¶ñÂÖàÂà§Êñ≠Êñ∞ÊóßËäÇÁÇπÊòØÂê¶Â≠òÂú®‰∏îÊòØÂê¶‰∏∫Áõ∏ÂêåÁöÑvnodeÁ±ªÂûã
  + Â¶ÇÊûú‰∏çÂêå, ÂàôÈîÄÊØÅÊóßËäÇÁÇπ„ÄÇÊØîÂ¶Ç‰∏Ä‰∏™divÊõ¥Êñ∞Êàêp, ÊúÄÁÆÄÂçïÁöÑÊìç‰ΩúÂ∞±ÊòØÂà†Èô§div, Âú®ÊåÇËΩΩÊñ∞ÁöÑpËäÇÁÇπ
  + Â¶ÇÊûúÊòØÁõ∏ÂêåÁöÑvnodeÁ±ªÂûã, Â∞±ÈúÄË¶ÅËµ∞diffÊõ¥Êñ∞ÊµÅÁ®ã‰∫Ü
2. ‰ªñÁöÑÊõ¥Êñ∞ÊµÅÁ®ãÂ∑≤ÁªèÊòØÊ†πÊçÆ‰∏çÂêåÁöÑvnodeÁ±ªÂûãËµ∞‰∏çÂêåÁöÑÂ§ÑÁêÜÈÄªËæë, ‰æùÁÑ∂ÊòØ‰∏ªË¶ÅÁúãÊôÆÈÄöÂÖÉÁ¥†ËäÇÁÇπÂíåÁªÑ‰ª∂ÁöÑÂ§ÑÁêÜÊµÅÁ®ã
  + Â§ÑÁêÜÁªÑ‰ª∂
    - ÁªÑ‰ª∂ÁöÑÊõ¥Êñ∞ÊúÄÁªàËøòÊòØË¶ÅËΩ¨Êç¢ÊàêÂÜÖÈÉ®ÁúüÂÆûDOMÁöÑÊõ¥Êñ∞, ËÄåÊôÆÈÄöÂÖÉÁ¥†ÁöÑÂ§ÑÁêÜÊµÅÁ®ãÊâçÊòØÁúüÊ≠£ÂÅöDOMÊõ¥Êñ∞
    - ÁªÑ‰ª∂Êõ¥Êñ∞‰æùÁÑ∂Ë∞ÉÁî®[processComponent](/blogs/vue3-resource/core/4.html#processcomponent)
  + Â§ÑÁêÜÊôÆÈÄöÂÖÉÁ¥†ËäÇÁÇπ
    - ÈÄöËøáË∞ÉÁî® [processElement](/blogs/vue3-resource/core/4.html#processelement)

```ts
const patch: PatchFn = (
    n1,
    n2,
    container,
    anchor = null,
    parentComponent = null,
    parentSuspense = null,
    isSVG = false,
    slotScopeIds = null,
    optimized = false
  ) => {
    // patching & not same type, unmount old tree
    // Â¶ÇÊûúÂ≠òÂú®Êñ∞ÊóßËäÇÁÇπ, ‰∏îÊñ∞ÊóßËäÇÁÇπÁ±ªÂûã‰∏çÂêåÔºåÂàôÈîÄÊØÅÊóßËäÇÁÇπ
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1)
      unmount(n1, parentComponent, parentSuspense, true)
      n1 = null
    }

    if (n2.patchFlag === PatchFlags.BAIL) {
      optimized = false
      n2.dynamicChildren = null
    }

    const { type, ref, shapeFlag } = n2
    switch (type) {
      case Text:
        // Â§ÑÁêÜÊñáÊú¨ËäÇÁÇπ
        processText(n1, n2, container, anchor)
        break
      case Comment:
        // Â§ÑÁêÜÊ≥®ÈáäËäÇÁÇπ
        processCommentNode(n1, n2, container, anchor)
        break
      case Static:
        // Â§ÑÁêÜÈùôÊÄÅËäÇÁÇπ
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG)
        } else if (__DEV__) {
          patchStaticNode(n1, n2, container, isSVG)
        }
        break
      case Fragment:
        // Â§ÑÁêÜFragment
        processFragment(
          n1,
          n2,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        )
        break
      default:
        if (shapeFlag & ShapeFlags.ELEMENT) {
          // Â§ÑÁêÜÊôÆÈÄöDOMÂÖÉÁ¥†
          processElement(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          )
        } else if (shapeFlag & ShapeFlags.COMPONENT) {
          // Â§ÑÁêÜÁªÑ‰ª∂
          processComponent(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          )
        } else if (shapeFlag & ShapeFlags.TELEPORT) {
          // Â§ÑÁêÜTELEPORT
          ;(type as typeof TeleportImpl).process(
            n1 as TeleportVNode,
            n2 as TeleportVNode,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          )
        } else if (__FEATURE_SUSPENSE__ && shapeFlag & ShapeFlags.SUSPENSE) {
          // Â§ÑÁêÜSUSPENSE
          ;(type as typeof SuspenseImpl).process(
            n1,
            n2,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized,
            internals
          )
        } else if (__DEV__) {
          warn('Invalid VNode type:', type, `(${typeof type})`)
        }
    }

    // set ref
    if (ref != null && parentComponent) {
      setRef(ref, n1 && n1.ref, parentSuspense, n2)
    }
  }
```

## processComponent

ÂíåÊ∏≤ÊüìËøáÁ®ãÁ±ª‰ºº, Êõ¥Êñ∞ËøáÁ®ã‰πüÊòØ‰∏Ä‰∏™Ê†ëÁöÑÊ∑±Â∫¶‰ºòÂÖàÈÅçÂéÜËøáÁ®ã

‰∏ªË¶ÅÈÄöËøáÊâßË°å [updateComponent](/blogs/vue3-resource/core/4.html#updatecomponent) ÂáΩÊï∞Êõ¥Êñ∞Â≠êÁªÑ‰ª∂

ÈÄöËøá‰∏ãÈù¢ÁöÑÂàÜÊûêÊàë‰ª¨ÂèØ‰ª•Áü•ÈÅì, processComponent Â§ÑÁêÜÁªÑ‰ª∂ vnodeÔºåÊú¨Ë¥®‰∏äÂ∞±ÊòØÂéªÂà§Êñ≠Â≠êÁªÑ‰ª∂ÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞

Â¶ÇÊûúÈúÄË¶ÅÂàôÈÄíÂΩíÊâßË°åÂ≠êÁªÑ‰ª∂ÁöÑÂâØ‰ΩúÁî®Ê∏≤ÊüìÂáΩÊï∞Êù•Êõ¥Êñ∞

Âê¶Âàô‰ªÖ‰ªÖÊõ¥Êñ∞‰∏Ä‰∫õ vnode ÁöÑÂ±ûÊÄßÔºåÂπ∂ËÆ©Â≠êÁªÑ‰ª∂ÂÆû‰æã‰øùÁïôÂØπÁªÑ‰ª∂ vnode ÁöÑÂºïÁî®ÔºåÁî®‰∫éÂ≠êÁªÑ‰ª∂Ëá™Ë∫´Êï∞ÊçÆÂèòÂåñÂºïËµ∑ÁªÑ‰ª∂ÈáçÊñ∞Ê∏≤ÊüìÁöÑÊó∂ÂÄôÔºåÂú®Ê∏≤ÊüìÂáΩÊï∞ÂÜÖÈÉ®ÂèØ‰ª•ÊãøÂà∞Êñ∞ÁöÑÁªÑ‰ª∂ vnode„ÄÇ


```ts
const processComponent = (
    n1: VNode | null,
    n2: VNode,
    container: RendererElement,
    anchor: RendererNode | null,
    parentComponent: ComponentInternalInstance | null,
    parentSuspense: SuspenseBoundary | null,
    isSVG: boolean,
    slotScopeIds: string[] | null,
    optimized: boolean
  ) => {
    n2.slotScopeIds = slotScopeIds
    // Â¶ÇÊûún1(ÊóßÁöÑvnode)‰∏çÂ≠òÂú®, ÂàôÊâßË°åÊåÇËΩΩÈÄªËæë(ÊåÇËΩΩÂàÜ‰∏∫ÁºìÂ≠òÁªÑ‰ª∂Áõ¥Êé•ÊøÄÊ¥ªÂíåÊñ∞ÁªÑ‰ª∂ÊåÇËΩΩ)
    if (n1 == null) {
      // ÊåÇËΩΩÁªÑ‰ª∂
    } else {
      // ÊóßÁöÑvnodeÂ≠òÂú®, ÂàôÊâßË°åÊõ¥Êñ∞ÈÄªËæë
      updateComponent(n1, n2, optimized)
    }
  }
```

## updateComponent

updateComponentÂáΩÊï∞Âú®Êõ¥Êñ∞Â≠êÁªÑ‰ª∂ÁöÑÊó∂ÂÄô‰ºöÂÖàÊâßË°å `shouldUpdateComponent` ÂáΩÊï∞, Ê†πÊçÆÊñ∞ÊóßÂ≠êÁªÑ‰ª∂vnodeÊù•Âà§Êñ≠ÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞Â≠êÁªÑ‰ª∂

Âú® shouldUpdateComponent ÂáΩÊï∞ÂÜÖÈÉ®, ‰∏ªË¶ÅÊòØÈÄöËøáÊ£ÄÊµãÂíåÂØπÊØîÁªÑ‰ª∂vnode‰∏≠ÁöÑprops, children, dirs, transitionÁ≠âÂ±ûÊÄß, Êù•ÂÜ≥ÂÆöÂ≠êÁªÑ‰ª∂ÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞

Âõ†‰∏∫‰∏Ä‰∏™ÁªÑ‰ª∂ÁöÑÂ≠êÁªÑ‰ª∂ÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞, ‰∏ªË¶Å‰æùÊçÆÂ≠êÁªÑ‰ª∂vnodeÊòØÂê¶Â≠òÂú®‰∏Ä‰∫õ‰ºöÂΩ±ÂìçÁªÑ‰ª∂Êõ¥Êñ∞ÁöÑÂ±ûÊÄßÂèòÂåñËøõË°åÂà§Êñ≠, Â¶ÇÊûúÂ≠òÂú®Â∞±‰ºöÊõ¥Êñ∞Â≠êÁªÑ‰ª∂

> ËôΩÁÑ∂vueÁöÑÊõ¥Êñ∞Á≤íÂ∫¶ÊòØÁªÑ‰ª∂Á∫ßÂà´ÁöÑ, ÁªÑ‰ª∂ÁöÑÊï∞ÊçÆÂèòÂåñÂè™‰ºöÂΩ±ÂìçÂΩìÂâçÁªÑ‰ª∂ÁöÑÊõ¥Êñ∞
> 
> ‰ΩÜÊòØÂú®ÁªÑ‰ª∂Êõ¥Êñ∞ÁöÑËøáÁ®ã‰∏≠, ‰πü‰ºöÂØπÂ≠êÁªÑ‰ª∂ÂÅö‰∏ÄÂÆöÁöÑÊ£ÄÊü•, Âà§Êñ≠Â≠êÁªÑ‰ª∂ÊòØÂê¶‰πüÈúÄË¶ÅÊõ¥Êñ∞, Âπ∂ÈÄöËøáÊüêÁßçÊú∫Âà∂ÈÅøÂÖçÂ≠êÁªÑ‰ª∂ÈáçÂ§çÊõ¥Êñ∞
> 
> Âú®updateComponentÂáΩÊï∞‰∏≠, Â¶ÇÊûú `shouldUpdateComponent`ÂáΩÊï∞ÊâßË°åËøîÂõûtrue, ÈÇ£‰πàÂú®ÂÆÉÁöÑÊúÄÂêé, ÂÖàÊâßË°å`invalidateJob(instance.update)`Êù•ÈÅøÂÖçÂ≠êÁªÑ‰ª∂Âõ†Ëá™Ë∫´Êï∞ÊçÆÂèòÂåñÂØºËá¥ÁöÑÈáçÂ§çÊõ¥Êñ∞
> 
> ÁÑ∂ÂêéÁªßÁª≠ÊâßË°åÂ≠êÁªÑ‰ª∂ÁöÑÂâØ‰ΩúÁî®Ê∏≤ÊüìÂáΩÊï∞ `instance.update`Êù•‰∏ªÂä®Ëß¶ÂèëÂ≠êÁªÑ‰ª∂ÁöÑÊõ¥Êñ∞
> 
> Êé•ÁùÄËøõÂÖ•[instance.update](/blogs/vue3-resource/core/4.html#update)
> 
> Â¶ÇÊûú‰∏çÈúÄË¶ÅÊõ¥Êñ∞, ÂàôÂ≠êÁªÑ‰ª∂ÂÆû‰æã‰øùÁïôÂØπÁªÑ‰ª∂vnodeÁöÑÂºïÁî®, ‰ªÖ‰ªÖÊõ¥Êñ∞‰∏Ä‰∫õvnodeÁöÑÂ±ûÊÄß
> 
> Âú®Â≠êÁªÑ‰ª∂Ëá™Ë∫´Êï∞ÊçÆÂèòÂåñÂºïËµ∑ÁªÑ‰ª∂ÈáçÊñ∞Ê∏≤ÊüìÁöÑÊó∂ÂÄô, ÂÜçÊ∏≤ÊüìÂáΩÊï∞ÂÜÖÈÉ®ÂèØ‰ª•ÊãøÂà∞Êñ∞ÁöÑÁªÑ‰ª∂vnode

```ts
const updateComponent = (n1: VNode, n2: VNode, optimized: boolean) => {
    const instance = (n2.component = n1.component)!
    // Ê†πÊçÆÊñ∞ÊóßÂ≠êÁªÑ‰ª∂vnodeÂà§Êñ≠ÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (
        __FEATURE_SUSPENSE__ &&
        instance.asyncDep &&
        !instance.asyncResolved
      ) {
        // ÂºÇÊ≠•ÁªÑ‰ª∂Êõ¥Êñ∞ÈÄªËæë
        ...
        return
      } else {
        // Êñ∞ÁöÑÂ≠êÁªÑ‰ª∂vnodeËµãÂÄºÁªôinstance.next
        instance.next = n2
        // Â≠êÁªÑ‰ª∂‰πüÂèØËÉΩÂõ†‰∏∫Êï∞ÊçÆÂèòÂåñË¢´Ê∑ªÂä†Âà∞Êõ¥Êñ∞ÈòüÂàóÈáå‰∫Ü, ÁßªÈô§‰ªñ‰ª¨Èò≤Ê≠¢ÂØπ‰∏Ä‰∏™Â≠êÁªÑ‰ª∂ÈáçÂ§çÊõ¥Êñ∞
        invalidateJob(instance.update)
        // ÊâßË°åÂ≠êÁªÑ‰ª∂ÁöÑÂâØ‰ΩúÁî®Ê∏≤ÊüìÂáΩÊï∞
        instance.update()
      }
    } else {
      // ‰∏çÈúÄË¶ÅÊõ¥Êñ∞ÂàôÁõ¥Êé•Â§çÂà∂ÂéüÁªÑ‰ª∂Âç≥ÂèØ
      n2.component = n1.component
      n2.el = n1.el
      instance.vnode = n2
    }
  }
```

## update 

updateÂáΩÊï∞ÂÖ∂ÂÆûÂÆö‰πâ‰∫ésetupRenderEffect(ÂâØ‰ΩúÁî®Ê∏≤ÊüìÂáΩÊï∞)‰∏≠

ÂÖ∂ÂÆûÁªÑ‰ª∂Êõ¥Êñ∞ÁöÑÈÄªËæëÂæàÂ•ΩÁêÜËß£Ôºö

1. Âú®Êõ¥Êñ∞ÁªÑ‰ª∂ÁöÑDOMÂâç, ÈúÄË¶ÅÂÖàÊõ¥Êñ∞ÁªÑ‰ª∂vnodeËäÇÁÇπ‰ø°ÊÅØ, ÂåÖÊã¨Êõ¥ÊîπÁªÑ‰ª∂ÂÆû‰æãÁöÑvnodeÊåáÈíà, Êõ¥Êñ∞propsÂíåÊõ¥Êñ∞ÊèíÊßΩÁ≠â‰∏ÄÁ≥ªÂàóÊìç‰Ωú
2. Âõ†‰∏∫ÁªÑ‰ª∂Âú®Á®çÂêéÊâßË°årenderComponentRootÊó∂‰ºöÈáçÊñ∞Ê∏≤ÊüìÊñ∞ÁöÑÂ≠êÊ†ëvnode, ‰æùËµñ‰∫ÜÊõ¥Êñ∞ÂêéÁöÑÁªÑ‰ª∂vnode‰∏≠ÁöÑpropsÂíåslotsÁ≠âÊï∞ÊçÆ
3. ‰∏ªË¶ÅÈÄöËøá updateComponentPreRenderÂÆûÁé∞, ‰∏ªË¶ÅÂÅö‰∫ÜÂ¶Ç‰∏ãÊìç‰Ωú
  + Âú® updateComponentPreRender ‰∏≠
  + È¶ñÂÖàÂ∞ÜÊñ∞ÁªÑ‰ª∂vnodeÁöÑcomponentÂ±ûÊÄßÊåáÂêëÁªÑ‰ª∂ÂÆû‰æã
  + ÁºìÂ≠òÊóßÁªÑ‰ª∂vnodeÁöÑpropsÂ±ûÊÄß
  + ÁªÑ‰ª∂ÂÆû‰æãÁöÑvnodeÂ±ûÊÄßÊåáÂêëÊñ∞ÁöÑÁªÑ‰ª∂vnode
  + Ê∏ÖÁ©∫nextÂ±ûÊÄß, ‰∏∫‰∏ã‰∏ÄÊ¨°Êõ¥Êñ∞ÂÅöÂáÜÂ§á
  + Êõ¥Êñ∞props
  + Êõ¥Êñ∞ÊèíÊßΩ
```ts
// updateComponentPreRender
const updateComponentPreRender = (
  instance: ComponentInternalInstance,
  nextVNode: VNode,
  optimized: boolean
) => {
  // Êñ∞ÁªÑ‰ª∂vnodeÁöÑcomponentÂ±ûÊÄßÊåáÂêëÁªÑ‰ª∂ÂÆû‰æã
  nextVNode.component = instance
  // ÁºìÂ≠òÊóßÁªÑ‰ª∂vnodeÁöÑpropsÂ±ûÊÄß
  const prevProps = instance.vnode.props
  // ÁªÑ‰ª∂ÂÆû‰æãÁöÑvnodeÂ±ûÊÄßÊåáÂêëÊñ∞ÁöÑÁªÑ‰ª∂vnode
  instance.vnode = nextVNode
  // Ê∏ÖÁ©∫nextÂ±ûÊÄß, ‰∏∫‰∫Ü‰∏ã‰∏ÄÊ¨°Êõ¥Êñ∞ÂáÜÂ§á
  instance.next = null
  // Êõ¥Êñ∞props
  updateProps(instance, nextVNode.props, prevProps, optimized)
  // Êõ¥Êñ∞ÊèíÊßΩ
  updateSlots(instance, nextVNode.children)
  ...
}
```

4. ÊâÄ‰ª•‰∏Ä‰∏™ÁªÑ‰ª∂ÈáçÊñ∞Ê∏≤ÊüìÂèØËÉΩ‰ºöÊúâ‰∏§ÁßçÊÉÖÂÜµ:
  + ‰∏ÄÁßçÊòØÁªÑ‰ª∂Êú¨Ë∫´ÁöÑÊï∞ÊçÆÂèòÂåñ, ËøôÁßçÊÉÖÂÜµ‰∏ãnextÊòØnull
  + Âè¶‰∏ÄÁßçÊòØÁà∂ÁªÑ‰ª∂Âú®Êõ¥Êñ∞ÁöÑËøáÁ®ã‰∏≠, ÈÅáÂà∞Â≠êÁªÑ‰ª∂ËäÇÁÇπ, ÂÖàÂà§Êñ≠Â≠êÁªÑ‰ª∂ÊòØÂê¶ÈúÄË¶ÅÊõ¥Êñ∞
  + Â¶ÇÊûúÈúÄË¶ÅÂàô‰∏ªÂä®ÊâßË°åÂ≠êÁªÑ‰ª∂ÁöÑÈáçÊñ∞Ê∏≤ÊüìÊñπÊ≥ï, ËøôÁßçÊÉÖÂÜµ‰∏ãnextÂ∞±ÊòØÊñ∞ÁöÑÂ≠êÁªÑ‰ª∂vnode
5. Ëøô‰∏™Âú∞ÊñπÂèØËÉΩËøò‰ºöÂ≠òÂú®‰∏Ä‰∏™ÁñëÈóÆ, ÈÇ£Â∞±ÊòØËøô‰∏™Â≠êÁªÑ‰ª∂ÂØπÂ∫îÁöÑÊñ∞ÁöÑÁªÑ‰ª∂vnodeÊòØ‰ªÄ‰πàÊó∂ÂÄôÂàõÂª∫ÁöÑÂë¢?
  + Á≠îÊ°àÂæàÁÆÄÂçï, ‰ªñÊòØÂú®Áà∂ÁªÑ‰ª∂ÈáçÊñ∞Ê∏≤ÊüìÁöÑËøáÁ®ã‰∏≠, ÈÄöËøárenderComponentRootÊ∏≤ÊüìÂ≠êÊ†ëvnodeÁöÑÊó∂ÂÄôÁîüÊàê
  + Âõ†‰∏∫Â≠êÊ†ëvnodeÊòØ‰∏™Ê†ëÂΩ¢ÁªìÊûÑ, ÈÄöËøáÈÅçÂéÜÂÆÉÁöÑÂ≠êËäÇÁÇπÂ∞±ÂèØ‰ª•ËÆøÈóÆÂà∞ÂÖ∂ÂØπÂ∫îÁöÑÁªÑ‰ª∂vnode
```ts
instance.update = effect(function componentEffect() {
      if (!instance.isMounted) {
        // ÂàùÂßãÊ∏≤ÊüìÈÄªËæë
      } else {
        // Êõ¥Êñ∞ÁªÑ‰ª∂
        // updateComponent
        // This is triggered by mutation of component's own state (next: null)
        // OR parent calling processComponent (next: VNode)
        let { next, bu, u, parent, vnode } = instance
        let originNext = next
        let vnodeHook: VNodeHook | null | undefined
        if (__DEV__) {
          pushWarningContext(next || instance.vnode)
        }

        // nextË°®Á§∫Êñ∞ÁöÑÁªÑ‰ª∂VNode
        // ËøôÈáåÂÖàÂà§Êñ≠Êñ∞ÁöÑÁªÑ‰ª∂ÂÆû‰æã‰∏≠ÊòØÂê¶ÊúâÊñ∞ÁöÑÁªÑ‰ª∂VNode(ËøôÈáåËÆæËÆ°‰∏Ä‰∏™ÁªÑ‰ª∂Êõ¥Êñ∞ÁöÑÈÄªËæë, Á®çÂêé‰ºöËØ¥, Ëøô‰πüÊòØÈúÄË¶ÅÂà§Êñ≠ÁöÑÂéüÂõ†)
        if (next) {
          // ÊúâÂàôÊõ¥Êñ∞ÁªÑ‰ª∂VNode
          next.el = vnode.el
          // Êõ¥Êñ∞ÁªÑ‰ª∂vnodeËäÇÁÇπ‰ø°ÊÅØ
          updateComponentPreRender(instance, next, optimized)
        } else {
          // Ê≤°ÊúâÂàônextÊåáÂêë‰πãÂâçÁöÑÁªÑ‰ª∂VNode
          next = vnode
        }
        // Ê∏≤ÊüìÊñ∞ÁöÑÂ≠êÊ†ëvnode
        const nextTree = renderComponentRoot(instance)
        // ÁºìÂ≠òÊóßÁöÑÂ≠êÊ†ëvnode
        const prevTree = instance.subTree
        // Êõ¥Êñ∞Â≠êÊ†ëvnode
        instance.subTree = nextTree
        // ÁªÑ‰ª∂Êõ¥Êñ∞Ê†∏ÂøÉÈÄªËæë, Ê†πÊçÆÊñ∞ÊóßÂ≠êÊ†ëvnodeÂÅöpatch
        patch(
          prevTree,
          nextTree,
          // parent may have changed if it's in a teleport
          // Â¶ÇÊûúÂú®teleportÁªÑ‰ª∂‰∏≠Áà∂ËäÇÁÇπÂèØËÉΩÂ∑≤ÁªèÊîπÂèò, ÊâÄ‰ª•ÂÆπÂô®Áõ¥Êé•ÊâæÊóßÊ†ëDOMÂÖÉÁ¥†ÁöÑÁà∂ËäÇÁÇπ
          hostParentNode(prevTree.el!)!,
          // anchor may have changed if it's in a fragment
          // ÂèÇËÄÉËäÇÁÇπ(ÈîöÁÇπ)Âú®fragmentÁöÑÊÉÖÂÜµÂèØËÉΩÊîπÂèò, ÊâÄ‰ª•Áõ¥Êé•ÊâæÊóßÊ†ëDOMÂÖÉÁ¥†ÁöÑ‰∏ã‰∏Ä‰∏™ËäÇÁÇπ
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        )
        // ÁºìÂ≠òÊõ¥Êñ∞ÂêéÁöÑDOMËäÇÁÇπ
        next.el = nextTree.el
        if (originNext === null) {
          // self-triggered update. In case of HOC, update parent component
          // vnode el. HOC is indicated by parent instance's subTree pointing
          // to child component's vnode
          updateHOCHostEl(instance, nextTree.el)
        }
      }
    }, __DEV__ ? createDevEffectOptions(instance) : prodEffectOptions)
```

## processElement

ÂÖÉÁ¥†Êõ¥Êñ∞ÈÄªËæëÊ†∏ÂøÉÂ∞±ÊòØÊâßË°å patchElement

ËÄåÂú®patchElement‰∏≠, ‰πüÂè™ÂÅö‰∏§‰ª∂‰∫ã:

+ Êõ¥Êñ∞props
  + ‰∏ãÈù¢ÁöÑ patchPropsÂáΩÊï∞Â∞±ÊòØÂú®Êõ¥Êñ∞DOMËäÇÁÇπÁöÑclass, style, event‰ª•ÂèäÂÖ∂‰ªñÁöÑ‰∏Ä‰∫õDOMÂ±ûÊÄß 
+ Êõ¥Êñ∞Â≠êËäÇÁÇπ
  + ËøôÈáåÁúã‰∏Ä‰∏ãpatchChildrenÁöÑÂÆûÁé∞
    - È¶ñÂÖàÊ†πÊçÆpatchFlag > 0‰πüÂ∞±ÊòØÂ≠òÂú®patchFlag, Ëøõ‰∏ÄÊ≠•Âà§Êñ≠ÊòØÂê¶Â§ÑÁêÜfragment
    - Â¶ÇÊûúÊúâ, ÂàôÂ§ÑÁêÜfragment
    - Êé•ÁùÄÂ§ÑÁêÜÈùûfragmentÁöÑÂ≠êËäÇÁÇπ, ÂÖ±‰∏âÁßçÊÉÖÂÜµ, Êï∞ÁªÑ„ÄÅÊñáÊú¨ËäÇÁÇπÂíåÁ©∫ËäÇÁÇπ
    - Â¶ÇÊûúÂΩìÂâçËäÇÁÇπÊòØÊñáÊú¨ËäÇÁÇπ, ‰πãÂâçÊòØÊï∞ÁªÑ, ÂàôÂà†Èô§ÂéüÊúâÂ≠êËäÇÁÇπ
    - Â¶ÇÊûúÂΩìÂâçËäÇÁÇπÊòØÊñáÊú¨ËäÇÁÇπ, ‰πãÂâçÊòØÊñáÊú¨, ‰∏î‰∏§‰∏™ÊñáÊú¨ÂÜÖÂÆπ‰∏çÁ≠â, ÂàôÁõ¥Êé•Êõ¥Êñ∞ÊñáÊú¨ÂÜÖÂÆπ, ÊõøÊç¢Êñ∞ÁöÑÊñáÊú¨
    - Â¶ÇÊûú‰πãÂâçÂ≠êËäÇÁÇπÊòØÊï∞ÁªÑ, Êñ∞ÁöÑÂ≠êËäÇÁÇπËøòÊòØÊï∞ÁªÑ, ÂàôÊâßË°å patchKeyedChildren, ÂÅöÂÆåÊï¥ÁöÑdiffÊµÅÁ®ã, ÂíåÊõ¥Êñ∞Â∏¶keyÁöÑfragmentÁ±ª‰ºº(ËøôÊòØÊúÄÂ§çÊùÇÁöÑÊÉÖÂÜµ)
    - Â¶ÇÊûú‰πãÂâçÂ≠êËäÇÁÇπÊòØÊï∞ÁªÑ, Êñ∞ÁöÑÂ≠êËäÇÁÇπÊòØÊñáÊú¨ÊàñËÄÖÁ©∫ËäÇÁÇπ, ÂàôÂà†Èô§ÂéüÊúâÂ≠êËäÇÁÇπ
    - Â¶ÇÊûú‰πãÂâçÂ≠êËäÇÁÇπÊòØÊñáÊú¨ÊàñËÄÖÁ©∫, Êñ∞ÁöÑÂ≠êËäÇÁÇπÊòØÁ©∫ËäÇÁÇπ, ÂàôÂ∞ÜÂéüÊúâÊñáÊú¨‰ø°ÊÅØËÆæÁΩÆ‰∏∫Á©∫Â≠óÁ¨¶‰∏≤(‰∏çÁÆ°ÂéüÊù•ÊòØÊñáÊú¨ËøòÊòØÁ©∫ËäÇÁÇπ, Áé∞Âú®ÊòØÁ©∫ÁöÑÈÉΩÊõ¥Êñ∞ÊàêÁ©∫ÁöÑ)
    - Â¶ÇÊûú‰πãÂâçÂ≠êËäÇÁÇπÊòØÊñáÊú¨ÊàñÁ©∫, Êñ∞ÁöÑÂ≠êËäÇÁÇπÊòØÊï∞ÁªÑ, ÂàôÊåÇËΩΩÊñ∞ÁöÑÂ≠êËäÇÁÇπ

> ËøôÈáåÁî®Âá†Âº†ÂõæË°®Á§∫‰∏äËø∞ÊÉÖÂÜµ

1. ÊóßÁöÑÂ≠êËäÇÁÇπÊòØÁ∫ØÊñáÊú¨
![Á∫ØÊñáÊú¨ÊóßËäÇÁÇπ](./images/2.jpg)
2. ÊóßÂ≠êËäÇÁÇπÊòØÁ©∫
![Á©∫ËäÇÁÇπÊóßËäÇÁÇπ](./images/3.jpg)
3. ÊóßÂ≠êËäÇÁÇπÊòØÊï∞ÁªÑ
![Êï∞ÁªÑÊóßËäÇÁÇπ](./images/4.png)

```ts
const patchChildren: PatchChildrenFn = (
    n1,
    n2,
    container,
    anchor,
    parentComponent,
    parentSuspense,
    isSVG,
    slotScopeIds,
    optimized = false
  ) => {
    const c1 = n1 && n1.children
    const prevShapeFlag = n1 ? n1.shapeFlag : 0
    const c2 = n2.children

    const { patchFlag, shapeFlag } = n2
    // fast path
    if (patchFlag > 0) {
      // Â§ÑÁêÜÊúâkeyÁöÑfragment
      if (patchFlag & PatchFlags.KEYED_FRAGMENT) {
        // this could be either fully-keyed or mixed (some keyed some not)
        // presence of patchFlag means children are guaranteed to be arrays
        patchKeyedChildren(
          c1 as VNode[],
          c2 as VNodeArrayChildren,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        )
        return
      } else if (patchFlag & PatchFlags.UNKEYED_FRAGMENT) {
        // unkeyed
        // Â§ÑÁêÜÊ≤°ÊúâkeyÁöÑfragment
        patchUnkeyedChildren(
          c1 as VNode[],
          c2 as VNodeArrayChildren,
          container,
          anchor,
          parentComponent,
          parentSuspense,
          isSVG,
          slotScopeIds,
          optimized
        )
        return
      }
    }

    // children has 3 possibilities: text, array or no children.
    // ÈÄªËæë‰∏é, ‰∫åËÄÖÁõ∏Á≠âÂàôËøîÂõûÁõ∏Á≠âÁöÑÊï∞, Âê¶Âàô‰∏∫0
    // Èô§‰∫Üfragement‰πãÂ§ñ, Â≠êËäÇÁÇπËøòÊúâ 3 ÁßçÂèØËÉΩÊÉÖÂÜµÔºöÊñáÊú¨„ÄÅÊï∞ÁªÑ„ÄÅÁ©∫
    if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
      // ÂΩìÂâçËäÇÁÇπÊòØÊñáÊú¨ËäÇÁÇπ
      // text children fast path
      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        // Êï∞ÁªÑ -> ÊñáÊú¨ÁöÑÊõ¥Êñ∞, Âà†Èô§‰πãÂâçÁöÑÂ≠êËäÇÁÇπ
        unmountChildren(c1 as VNode[], parentComponent, parentSuspense)
      }
      if (c2 !== c1) {
        // ÊñáÊú¨ÂØπÊØî‰∏çÂêå, ÂàôÊõøÊç¢Êñ∞ÊñáÊú¨
        hostSetElementText(container, c2 as string)
      }
    } else {
      if (prevShapeFlag & ShapeFlags.ARRAY_CHILDREN) {
        // ‰πãÂâçÁöÑËäÇÁÇπÊòØÊï∞ÁªÑ
        // prev children was array
        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          // Áé∞Âú®ÁöÑËäÇÁÇπ‰πüÊòØÊï∞ÁªÑ, ÂÅöÂÆåÊï¥diffÊµÅÁ®ã
          // two arrays, cannot assume anything, do full diff
          patchKeyedChildren(
            c1 as VNode[],
            c2 as VNodeArrayChildren,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          )
        } else {
          // Êï∞ÁªÑ -> ÈùûÊñáÊú¨ÁöÑÂçïËäÇÁÇπ, ÂêåÊ†∑Âà†Èô§ÂéüÊù•ÁöÑËäÇÁÇπ
          // no new children, just unmount old
          unmountChildren(c1 as VNode[], parentComponent, parentSuspense, true)
        }
      } else {
        // ‰πãÂâçÁöÑÂ≠êËäÇÁÇπÊòØÊñáÊú¨ËäÇÁÇπÊàñËÄÖÁ©∫
        // Êñ∞ÁöÑÂ≠êËäÇÁÇπÊòØÊï∞ÁªÑÊàñËÄÖÁ©∫
        // prev children was text OR null
        // new children is array OR null
        if (prevShapeFlag & ShapeFlags.TEXT_CHILDREN) {
          // ‰πãÂâçÊòØÊñáÊú¨ËäÇÁÇπ, ÂàôÂ∞ÜÂÖ∂Ê∏ÖÁ©∫
          hostSetElementText(container, '')
        }
        // mount new if array
        if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
          // Â¶ÇÊûúÊñ∞ËäÇÁÇπÊòØÊï∞ÁªÑ, ÂàôÊåÇËΩΩÊñ∞ÁöÑÂ≠êËäÇÁÇπ
          mountChildren(
            c2 as VNodeArrayChildren,
            container,
            anchor,
            parentComponent,
            parentSuspense,
            isSVG,
            slotScopeIds,
            optimized
          )
        }
      }
    }
  }
```

ÂÖ∂ÂÆûËøôÊòØÂæàÂ•ΩÁêÜËß£ÁöÑÔºåÂõ†‰∏∫‰∏Ä‰∏™ DOM ËäÇÁÇπÂÖÉÁ¥†Â∞±ÊòØÁî±ÂÆÉËá™Ë∫´ÁöÑ‰∏Ä‰∫õÂ±ûÊÄßÂíåÂ≠êËäÇÁÇπÊûÑÊàêÁöÑ„ÄÇ

```ts
const processElement = (
  n1: VNode | null,
  n2: VNode,
  container: RendererElement,
  anchor: RendererNode | null,
  parentComponent: ComponentInternalInstance | null,
  parentSuspense: SuspenseBoundary | null,
  isSVG: boolean,
  slotScopeIds: string[] | null,
  optimized: boolean
) => {
  if (n1 == null) {
    // ÊåÇËΩΩÂÖÉÁ¥†ËäÇÁÇπ
  } else {
    // Êõ¥Êñ∞ÂÖÉÁ¥†ËäÇÁÇπ
    patchElement(
      n1,
      n2,
      parentComponent,
      parentSuspense,
      isSVG,
      slotScopeIds,
      optimized
    )
  }
}
const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, optimized) => {
  const el = (n2.el = n1.el)
  const oldProps = (n1 && n1.props) || EMPTY_OBJ
  const newProps = n2.props || EMPTY_OBJ
  // Êõ¥Êñ∞ props
  patchProps(el, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG)
  const areChildrenSVG = isSVG && n2.type !== 'foreignObject'
  // Êõ¥Êñ∞Â≠êËäÇÁÇπ
  patchChildren(n1, n2, el, null, parentComponent, parentSuspense, areChildrenSVG)
}
```

