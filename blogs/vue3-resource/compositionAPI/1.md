---
title: Vue3Setup - 组件渲染前的初始化过程
date: 2022-09-21
tags:
    - vue
categories:
    - vue3源码
---

# 组件渲染前的初始化过程

Vue3允许我们在编写组件时, 添加一个setup启动函数, 它是 CompositionAPI 逻辑组织的入口

## compositionAPI案例

```vue
<template>
  <button @click="increment">
    Count is: {{ state.count }}, double is: {{ state.double }}
  </button>
</template>
<script>
import { reactive, computed } from 'vue'
export default {
  setup() {
    const state = reactive({
      count: 0,
      double: computed(() => state.count * 2)
    })
    function increment() {
      state.count++
    }
    return {
      state,
      increment
    }
  }
}
</script>
```

可以看到这段代码和Vue2的组件写法类似, 多了一个setup启动函数, 另外组件中也没有定义props, data, computed这些options

在setup函数内部, 定义了一个响应式对象state, 他是通过reactive API 创建的。state对象有count和double两个属性, 其中count对应一个数字属性的值, 而double通过computedAPI创建, 对应一个计算属性的值。

这里需要注意的是, `模板中引用的变量state和increment包含在setup函数的返回对象中, 他们是如何建立联系的呢?`

在Vue2中编写组件时, 会在 props、data、methods、computed 等 options 中定义一些变量。在组件初始化阶段，Vue 内部会处理这些 options，即把定义的变量添加到了组件实例上。等模板编译成 render 函数的时候，内部通过 with(this){} 的语法去访问在组件实例中的变量。

接下来将重点分析一下Vue3中既支持定义setup函数, 而且在模板render的时候, 有可以访问到setup函数返回的值是如何实现的

## 创建和设置组件实例

首先，我们来回顾一下组件的渲染流程：

1. 创建 vnode
2. 渲染 vnode
3. 生成 DOM。

其中渲染VNode的过程主要就是挂载组件

```ts
const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
  // 创建组件实例
  const instance = (initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense))
  // 设置组件实例
  setupComponent(instance)
  // 设置并运行带副作用的渲染函数
  setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized)
}
```
可以看到，这段挂载组件的代码主要做了三件事情：创建组件实例、设置组件实例和设置并运行带副作用的渲染函数。

其中前两个事情就和现在要分析的过程息息相关

重点就在`创建组件实例`和`设置组件实例`上

## 创建组件实例

先看创建组件实例的流程，我们要关注 `createComponentInstance` 方法的实现：

```ts
export function createComponentInstance(
  vnode: VNode,
  parent: ComponentInternalInstance | null,
  suspense: SuspenseBoundary | null
) {
  // vnode类型
  const type = vnode.type as ConcreteComponent
  // inherit parent app context - or - if root, adopt from root vnode
  // 继承父组件实例上的 appContext, 如果是根组件, 则直接从根vnode中取
  const appContext =
    (parent ? parent.appContext : vnode.appContext) || emptyAppContext

  const instance: ComponentInternalInstance = {
    // 组件唯一id
    uid: uid++,
    // 组件vnode
    vnode,
    // vnode节点类型
    type,
    // 父组件实例
    parent,
    // app上下文
    appContext,
    // 根组件实例
    root: null!, // to be immediately set
    // 新的组件vnode
    next: null,
    // 子节点vnode
    subTree: null!, // will be set synchronously right after creation
    // 带副作用更新函数
    update: null!, // will be set synchronously right after creation
    // 渲染函数
    render: null,
    // 渲染上下文代理
    proxy: null,
    // 暴露给其他组件访问的属性, 如refs访问子组件时, 只有通过exposed属性暴露的才能被访问到
    exposed: null,
    // 带有with区块的渲染上下文代理
    withProxy: null,
    // 响应式相关对象
    effects: null,
    // 依赖属性, 可供给其下所有层级组件注入
    provides: parent ? parent.provides : Object.create(appContext.provides),
    // 渲染代理的属性访问缓存
    accessCache: null!,
    // 渲染缓存
    renderCache: [],

    // local resovled assets
    // 局部注册的组件
    components: null,
    // 局部注册的指令
    directives: null,

    // resolved props and emits options
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),

    // emit
    // 派发事件方法
    emit: null as any, // to be set immediately
    emitted: null,

    // state
    // 渲染上下文
    ctx: EMPTY_OBJ,
    // data 数据
    data: EMPTY_OBJ,
    // props 数据
    props: EMPTY_OBJ,
    // 普通dom节点属性
    attrs: EMPTY_OBJ,
    // 插槽
    slots: EMPTY_OBJ,
    // 组件或DOM的ref引用
    refs: EMPTY_OBJ,
    // setup函数返回的响应式结果
    setupState: EMPTY_OBJ,
    // setup 函数上下文数据
    setupContext: null,

    // suspense related
    // suspense相关
    suspense,
    // suspenseId
    suspenseId: suspense ? suspense.pendingId : 0,
    // suspense 异步依赖
    asyncDep: null,
    // suspense 异步依赖是否都已处理
    asyncResolved: false,

    // lifecycle hooks
    // not using enums here because it results in computed properties
    // 是否挂载
    isMounted: false,
    // 是否卸载
    isUnmounted: false,
    // 是否激活
    isDeactivated: false,
    // 生命周期, beforeCreate
    bc: null,
    // 生命周期, created
    c: null,
    // 生命周期, beforeMount
    bm: null,
    // 生命周期, mounted
    m: null,
    // 生命周期, beforeUpdate
    bu: null,
    // 生命周期, updated
    u: null,
    // 生命周期, unmounted
    um: null,
    // 生命周期, beforeUnmounted
    bum: null,
    // 生命周期 deactivated
    da: null,
    // 生命周期, activated
    a: null,
    // 生命周期 render triggered
    rtg: null,
    // 生命周期, render tracked
    rtc: null,
    // 生命周期, error capture
    ec: null
  }
  // 初始化渲染上下文
  if (__DEV__) {
    instance.ctx = createRenderContext(instance)
  } else {
    instance.ctx = { _: instance }
  }
  // 初始化根组件指针
  instance.root = parent ? parent.root : instance
  // 初始化派发事件方法
  instance.emit = emit.bind(null, instance)
  // 返回市里
  return instance
}
```

从上述代码可以看到, 组件实例instance上定义了很多属性, 但是千万不要被这些属性吓到

因为其中一些属性是为了实现某个场景或者某个功能所定义的, 只需要通过在代码中的注释大概知道他们是做什么的即可

Vue2使用 new Vue来初始化一个组件的实例, 但是到了Vue3, 我们是直接通过创建对象去创建组件的实例。这两种方式其实并无本质区别, 都是引用一个对象, 在整个组件的生命周期中去维护组件的状态数据和上下文环境

创建好instance实例后, 接下来就是设置它的一些属性。目前已经完成了组件的上下文, 根组件指针以及派发时间方法的设置。后续会继续分析更多instance实例属性的设置逻辑

## 组件实例的设置流程

接下来是组件实例的设置流程, 对setup函数的处理就是在这里完成的

以下是 setupComponent 方法的实现:

```ts
export function isStatefulComponent(instance: ComponentInternalInstance) {
  return instance.vnode.shapeFlag & ShapeFlags.STATEFUL_COMPONENT
}
export function setupComponent(
  instance: ComponentInternalInstance,
  isSSR = false
) {
  // 是否SSR, 默认为false, 渲染vnode时为false
  isInSSRComponentSetup = isSSR

  const { props, children } = instance.vnode
  // 判断一个组件是否为有状态的组件(函数式组件(FunctionalComponent)没有状态)
  const isStateful = isStatefulComponent(instance)
  // 初始化props
  initProps(instance, props, isStateful, isSSR)
  // 初始化插槽
  initSlots(instance, children)

  // 设置有状态的组件实例
  const setupResult = isStateful
    ? setupStatefulComponent(instance, isSSR)
    : undefined
  isInSSRComponentSetup = false
  // 返回有状态的组件实例
  return setupResult
}
```

可以看到从组件vnode中获取了props, children, 然后根据shapeFlag属性判断是否为无状态组件

接着对props和插槽进行初始化

根据组件是否为有状态组件, 来决定是否进一步设置有状态组件实例

## setupStatefulComponent

主要通过 `setupStatefulComponent` 设置有状态组件实例, 它主要做三件事:

1. 创建渲染上下文代理
2. 判断处理setup函数
3. 完成组件实例设置

实现如下

```ts
function setupStatefulComponent(
  instance: ComponentInternalInstance,
  isSSR: boolean
) {
  const Component = instance.type as ComponentOptions

  if (__DEV__) {
    // 开发环境校验名称等
    ...
  }
  // 0. create render proxy property access cache
  // 创建渲染代理的属性访问缓存
  instance.accessCache = Object.create(null)
  // 1. create public instance / render proxy
  // also mark it raw so it's never observed
  // 创建渲染上下文代理
  instance.proxy = new Proxy(instance.ctx, PublicInstanceProxyHandlers)
  if (__DEV__) {
    // 开发环境允许通过instance直接访问props中属性, 通过Object.definePropertys设置代理
    exposePropsOnRenderContext(instance)
  }
  // 2. call setup()
  // 处理setup函数
  const { setup } = Component
  if (setup) {
    // 如果setup函数带参数, 则创建一个 setupContext
    const setupContext = (instance.setupContext =
      setup.length > 1 ? createSetupContext(instance) : null)

    currentInstance = instance
    pauseTracking()
    // 执行setup函数, 获取结果
    const setupResult = callWithErrorHandling(
      setup,
      instance,
      ErrorCodes.SETUP_FUNCTION,
      [__DEV__ ? shallowReadonly(instance.props) : instance.props, setupContext]
    )
    resetTracking()
    currentInstance = null

    // 处理 setup 执行结果
    handleSetupResult(instance, setupResult, isSSR)
  } else {
    // 完成组件实例设置
    finishComponentSetup(instance, isSSR)
  }
}
```

## 创建渲染上下文代理

首先是创建渲染上下文代理的流程, 主要对instance.ctx做了代理。

`在这里, 需要明白一点, 就是为什么需要代理?`

其实在Vue2中, 也有类似的数据代理逻辑, 比如props求值后的数据, 实际上存储在`this._props`上, 而data中定义的数据存储在`this._data`上

### 例子:

```vue
<template>
  <p>{{ msg }}</p>
</template>
<script>
export default {
  data() {
    msg: 1
  }
}
</script>
```

在组件初始化时, 组件定义的msg在组件内部是存储在this._data上的, 而模板渲染的时候访问`this.msg`, 实际上访问的是`this._data.msg`, 这是因为Vue2在初始化data的时, 做了一层proxy代理, 让this访问成员指向 `this._data`

到了Vue3, 为了方便维护, 可以把组件中不同状态的数据存储到不同的属性中, 比如存储到 setupState, ctx, data, props中

我们在执行组件渲染函数时, 为了方便用户使用，会执行访问渲染上下文instance.ctx中的属性, 所以我们也要做一层proxy, 对渲染上下文instance.ctx属性的访问和修改, 代理对 setupState, ctx, data, props中的数据访问和修改

明确了代理的需求后, 接下来就要分析proxy的几个方法: get, set和has

### get

当`访问 instance.ctx渲染上下文中的属性`时, 就会`进入get函数`, 实现如下:

```ts
export const PublicInstanceProxyHandlers: ProxyHandler<any> = {
  get({ _: instance }: ComponentRenderContext, key: string) {
    const {
      ctx,
      setupState,
      data,
      props,
      accessCache,
      type,
      appContext
    } = instance

    // let @vue/reactivity know it should never observe Vue public instances.
    // 当访问对象是 __v_skip 直接返回true
    if (key === ReactiveFlags.SKIP) {
      return true
    }

    // for internal formatters to know that this is a Vue instance
    // 让内部格式化程序知道这是一个 Vue 实例, 也就是说开发环境会访问 `__isVue`, 同样返回true
    if (__DEV__ && key === '__isVue') {
      return true
    }

    // data / props / ctx
    // This getter gets called for every property access on the render context
    // during render and is a major hotspot. The most expensive part of this
    // is the multiple hasOwn() calls. It's much faster to do a simple property
    // access on a plain object, so we use an accessCache object (with null
    // prototype) to memoize what access type a key corresponds to.
    let normalizedProps
    if (key[0] !== '$') {
      // setupState / data / props / ctx
      // 渲染代理的属性访问缓存中
      const n = accessCache![key]
      if (n !== undefined) {
        // 根据缓存类型直接从对应的数据源中取出
        switch (n) {
          case AccessTypes.SETUP:
            // setup中的属性
            return setupState[key]
          case AccessTypes.DATA:
            // data中的属性
            return data[key]
          case AccessTypes.CONTEXT:
            // ctx中的属性
            return ctx[key]
          case AccessTypes.PROPS:
            // props中的属性
            return props![key]
          // default: just fallthrough
        }
      } else if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
        // 满足setupState不为空对象并且key在setupState上
        // 记录当前key的缓存类型为SETUP
        accessCache![key] = AccessTypes.SETUP
        // 从 setupState 中取数据
        return setupState[key]
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        // 如果data不是空对象, 且key在data上
        // 基类缓存类型为DATA
        accessCache![key] = AccessTypes.DATA
        // 从data中取出值
        return data[key]
      } else if (
        // only cache other properties when instance has declared (thus stable)
        // props
        (normalizedProps = instance.propsOptions[0]) &&
        hasOwn(normalizedProps, key)
      ) {
        // 当期key在props上, 记录缓存类型
        accessCache![key] = AccessTypes.PROPS
        // 从props中取出
        return props![key]
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        // 当前key在ctx上, 记录缓存类型
        accessCache![key] = AccessTypes.CONTEXT
        // 从ctx中取出
        return ctx[key]
      } else if (!__FEATURE_OPTIONS_API__ || !isInBeforeCreate) {
        // 都取不到则记录缓存类型为其他, 再次进入时不会继续获取
        accessCache![key] = AccessTypes.OTHER
      }
    }

    const publicGetter = publicPropertiesMap[key]
    let cssModule, globalProperties
    // public $xxx properties
    // 公开的 $xxx 属性或方法
    if (publicGetter) {
      if (key === '$attrs') {
        track(instance, TrackOpTypes.GET, key)
        __DEV__ && markAttrsAccessed()
      }
      return publicGetter(instance)
    } else if (
      // css module (injected by vue-loader)
      (cssModule = type.__cssModules) &&
      (cssModule = cssModule[key])
    ) {
      // css模块, 通过vue-loader编译的时候注入
      return cssModule
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      // 用户自定的属性, 但却以$开头
      // user may set custom properties to `this` that start with `$`
      // 记录缓存为CONTEXT
      accessCache![key] = AccessTypes.CONTEXT
      // 从ctx中取出
      return ctx[key]
    } else if (
      // global properties
      // 全局定义的属性
      ((globalProperties = appContext.config.globalProperties),
      hasOwn(globalProperties, key))
    ) {
      // 直接取出即可
      return globalProperties[key]
    } else if (
      __DEV__ &&
      currentRenderingInstance &&
      (!isString(key) ||
        // #1091 avoid internal isRef/isVNode checks on component instance leading
        // to infinite warning loop
        key.indexOf('__v') !== 0)
    ) {
      if (
        data !== EMPTY_OBJ &&
        (key[0] === '$' || key[0] === '_') &&
        hasOwn(data, key)
      ) {
        // 如果在 data 中定义的数据以 $ 开头，会在开发环境报警告，因为 $ 是保留字符，不会做代理
        warn(
          `Property ${JSON.stringify(
            key
          )} must be accessed via $data because it starts with a reserved ` +
            `character ("$" or "_") and is not proxied on the render context.`
        )
      } else if (instance === currentRenderingInstance) {
        // 在模板中使用的变量如果没有定义，报警告
        warn(
          `Property ${JSON.stringify(key)} was accessed during render ` +
            `but is not defined on instance.`
        )
      }
    }
  }
}
```

通过上述代码可以看到, 函数首先判断key是不是以$开头, 这部分数据可能是setupState, data, props, ctx中的一种

其中data, props已经很熟悉了

setupState就是setup函数返回的数据, 稍后会详细说

ctx中包含了计算属性, 组件方法和用户自定义的一些数据

如果key不以$开头, 那么久依次判断setupState, data, props, ctx中是否包含这个key, 如果包含久返回对应值。

> 注意: 这个判断熟悉怒很重要, 在key相同时它会决定数据获取的优先级, 举个例子:

```vue
<template>
  <p>{{msg}}</p>
</template>
<script>
  import { ref } from 'vue'
  export default {
    data() {
      return {
        msg: 'msg from data'
      }
    },
    setup() {
      const msg = ref('msg from setup')
      return {
        msg
      }
    }
  }
</script>
```

这里在data和setup中都定义了msg变量, 但最终输出到界面上的是"msg from setup", 因为setupState的判断优先级要高于data

再回到get中, 可以看到这里定义了 accessCache 作为渲染代理的属性访问缓存, 它具体是干什么的呢? 

组件在渲染时会经常访问数据进而触发get函数, 这其中最昂贵的部分就是多次调用hasOwn去判断key在不在某个类型的数据中, 但是在普通对象上执行简单的属性访问相对要快得多

所以在第一次判断获取key对应的数据后, 可以利用 `accessCache[key]` 去缓存数据, 下一次再次根据key查找数据, 可以直接通过 `accessCache[key]`获取对应的值, 就不需要依次调用hasOwn去判断了, 这也是一种性能优化的小技巧

如果key以`$`开头, 那么接下来又会有一系列的判断, 首先判断是不是Vue内部公开的 `$xxx` 属性或方法, 比如`$parent`；然后判断是不是vue-loader编译注入的css模块内部的key；接着判断是不是用户自定义的以`$`开头的key；最后判断是不是全局属性。如果都不满足, 就剩两种情况了即在非生产环境下就会报两种类型的错误: 第一种是data中定义的数据以`$`开头的警告, 因为`$`是保留字符, 不会做代理；第二种是在模板中使用的变量没有定义的警告

### set

接下来是set的代理过程, 当`修改instance.ctx渲染上下文中的属性`时, 就会`进入set函数`, 实现如下:

```ts
export const PublicInstanceProxyHandlers: ProxyHandler<any> = {
  set(
    { _: instance }: ComponentRenderContext,
    key: string,
    value: any
  ): boolean {
    const { data, setupState, ctx } = instance
    if (setupState !== EMPTY_OBJ && hasOwn(setupState, key)) {
      // 给setupState赋值
      setupState[key] = value
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      // 给data赋值
      data[key] = value
    } else if (hasOwn(instance.props, key)) {
      // 给props赋值, 直接开发环境告警
      __DEV__ &&
        warn(
          `Attempting to mutate prop "${key}". Props are readonly.`,
          instance
        )
      return false
    }
    if (key[0] === '$' && key.slice(1) in instance) {
      // 给以vue开头的内部保留属性赋值直接告警
      __DEV__ &&
        warn(
          `Attempting to mutate public property "${key}". ` +
            `Properties starting with $ are reserved and readonly.`,
          instance
        )
      return false
    } else {
      // 开发环境下给全局属性赋值会通过 Object.defineProperty 对目标属性进行修改
      if (__DEV__ && key in instance.appContext.config.globalProperties) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          value
        })
      } else {
        // 生产环境直接给用户自定义的全局属性赋值
        ctx[key] = value
      }
    }
    return true
  }
}
```
结合代码来看，函数主要做的事情就是对渲染上下文 instance.ctx 中的属性赋值，它实际上是代理到对应的数据类型中去完成赋值操作的。这里仍然要注意顺序问题，和 get 一样，优先判断 setupState，然后是 data，接着是 props。

对之前的例子做一个修改:

```vue
<template>
  <p>{{ msg }}</p>
  <button @click="random">Random msg</button>
</template>
<script>
  import { ref } from 'vue'
  export default {
    data() {
      return {
        msg: 'msg from data'
      }
    },
    setup() {
      const msg = ref('msg from setup')
      return {
        msg
      }
    },
    methods: {
      random() {
        this.msg = Math.random()
      }
    }
  }
</script>
```

这里点击按钮会执行random函数, 这里的this指向就是instance.ctx, 修改this.msg就会触发set函数, 所以最终修改的就是setup中的msg

> 注意: 如果直接对props中的数据赋值, 在非生产环境中会收到一条警告, 这是因为直接修改props不符合数据单向流动的设计思想；如果对Vue内部以`$`开头的保留属性赋值, 同样也会收到警告

如果是用户自定义的属性, 比如在created生命周期中定义的数据, 它仅用于组件上下文的共享, 比如:

```ts
export default {
  created() {
    this.userMsg = 'msg from user'
  }
}
```

当执行 this.userMsg 赋值的时候，会触发 set 函数，最终 userMsg 会被保留到 ctx 中。

如果是开发环境则会使用Object.defineProperty为目标属性也就是userMsg修改值, 且设置为可枚举和可配置
