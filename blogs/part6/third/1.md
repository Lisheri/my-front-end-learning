---
title: 自动化构建
date: 2021-04-28
tags:
 - 自动化构建
categories: 
 - 前端工程化
---

# 自动化构建

## 自动化构建工作流

脱离运行环境兼容带来的问题, 在开发阶段使用提高效率的语法、规范和标准

最典型的工作常见是开发web应用时:

+ 使用ECMAScript Next 提高效率
+ Scss增强css
+ 使用模板引擎

直接使用的情况下, 浏览器是没办法直接识别的

通过自动化构建的的工具, 将那些不被支持的特性, 转换成能够识别的代码

## 体验一波

比如要使用scss提高css可编程性, 这就需要在构建阶段, 通过工具将scss构建为css

此处需要使用scss官方提供的一个scss模块: `yarn add scss --dev`

之后就可以使用scss去构建scss文件, 但是这样来说就会重复的去使用这些命令, 极其麻烦

### 使用npm scripts去包装使用的命令

具体来说就是在package.json中添加一个scripts字段, 是一个对象, 下面的键名就是使用的命令名字, 内容就是目标命令内容

同时 npm scripts也是实现自动化构建最简单的方式

可以使用一个叫做 browser-sync的模块去快速搞一个开发服务器测试命令

但是这样并没有一个样式可以搞, 所以可以在serve命令执行前, 利用scripts的钩子机制搞一个preserve, 他会自动在serve执行前执行

同时可以在build中添加一个 --watch, 可以监听文件的改变, 然后自动重新执行build命令, 但是这样会卡在这里, 这个时候需要一个`npm-run-all`, 通过内部的`run-p build serve`

browser-sync 下可以添加一个--files的命令, 可以监听后面设置的修改文件, 当文件发生变化后, 自动同步到浏览器中: `browser-sync . --files \"css/*.css"\"`, 避免了手动刷新浏览器的工作。

命令配置如下:

```json
"scripts": {
    "build": "scss scss/main.scss css/style.css --watch",
    "serve": "browser-sync . --files \"css/*.css\"",
    "start": "run-p build serve"
},
```
## 常用的自动化构建工具

+ Grunt: 插件生态非常完善, 基于临时文件实现, 构建速度较慢, 每一步都有磁盘读写操作, 处理环节越多, 文件读写次数越多
+ Gulp: 很好的解决了上述构建速度慢的问题, 基于内存构建, 相比于磁盘读写, 速度快了很多, 默认支持同时处理多个任务, 使用方式简单, 插件生态完善
+ FIS: 更像是捆绑套餐, 将需求尽可能继承在内部, 可以轻松处理资源加载,  模块化开发和代码部署, 甚至性能优化, 大而全。

上面两个更灵活, 下面的更全面, 也重。

