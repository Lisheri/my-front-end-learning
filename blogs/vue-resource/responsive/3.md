---
title: Vue初始化
date: 2022-04-23
tags:
    - vue
categories:
    - Vue源码
---

# Vue初始化

## Vue源码运行时的小问题

### js语法报错

在setting.json中将 `javascript.validate.enable`设置为false。

原因在于vscode是微软开发的, ts也是, vscode默认支持ts, 但是vscode不支持flow语法检查, 因此vue2.6源码疯狂报错(报错报的是类型只有在ts中支持s), 此时建议关闭。

### 泛型后续不高亮显示

需安装插件 `bebel javascript`

但是依然有一个问题无法解决, 那就是`代码链接`会失效(也就是无法快速跳转到定义处)

## Vue静态成员初始化

在`src/core/index.js`中调用了 `initGlobalAPI`这个方法中初始化了Vue的大多数静态成员

前面有过一段简单的讲解, 这里细说一下

1. 首先第一段代码通过`Object.defineProperty(Vue, 'config', configDef)`初始化`Vue.config`静态成员
   + 最上面的位置其实定义的是`Vue.config`的描述符, 通过`Object.defineProperty`来定义这个属性
   + `defineProperty`并不一定是用于定义响应式数据, 此时只不过是定义了一个属性
   + 首先在属性描述符上有一个get方法, 直接就是返回当前静态成员`config`(这个`config`从`src/core/config.js`中引入)
   + 其次如果是在开发环境的话, 会给这个对象增加一个set方法, 当我们直接给Vue.config赋值时, 就会触发set方法, 内部会给出一段警告, 告诉用户不要给Vue.config重新赋值, 但是可以在`Vue.config`下挂载对应的属性和方法
   + 其实往`Vue.config`上挂载方法的地方很近, 就在`platforms/web/runtime/index`中, 我们像其中挂载了一些方法用于判断属性是否为关键属性。
   + 具体实现如下:

```js
...
  const configDef = {}
  configDef.get = () => config
  if (process.env.NODE_ENV !== 'production') {
    configDef.set = () => {
      warn(
        'Do not replace the Vue.config object, set individual fields instead.'
      )
    }
  }
  // * 初始化 Vue.config 对象
  Object.defineProperty(Vue, 'config', configDef)
```
2. 定义了`Vue.util`, 并且挂载了一些API
   + 这些API是在文档中看不到的, 并且也不推荐使用
   + `Vue.util`: `warn/extend/Options/defineReactive`
3. 定义了三个静态方法 `Vue.set`、 `Vue.delete`和`Vue.nextTick`(这几个方法等响应式分析完后在回过来看)
4. 定义了`Vue.observable`静态方法, 内部调用了`observe`方法, 让入参对象变成一个响应式对象, 并返回这个响应式对象
5. 初始化`Vue.options`对象, 并扩展, 主要有 `components/directives/filters`
   + 首先使用Object.create(null)创建了一个空对象, 通过`Object.create(null)`可以直接将当前对象的`__proto__`设置为null, 也就是一个完全的空对象, 没有任何的原型方法, 可以提高性能
   + 遍历数组`ASSET_TYPES`, 内部有三个字符串成员, 分别为: `component/directive/filter`, 在`Vue.options`下通过`Object.create(null)`继续挂载了三个成员, 均初始化成了空对象, 也就是`Vue.options.components`、`Vue.options.directives`和`Vue.options.filters`。
   + 作用是用于存储全局的`组件`/`指令`和`过滤器`, 也就是用户通过`Vue.component`、`Vue.directive`和`Vue.filter`注册的这些全局的组件、指令和过滤器都会存储到这三个对象中
6. 在`Vue.options._base`上记录下了当前Vue的构造函数, 将来会用到
7. 调用`extend(Vue.options.components, builtInComponents)`方法, 将`builtInComponents`下的成员全部拷贝给`Vue.options.components`(上面初始化的空对象)
   + `extend` 方法的作用是将一个对象的所有属性拷贝到另一个对象中来
   + 传入了两个参数, 一个是to, 一个是form, 他会遍历form的成员, 然后拷贝给to
   + 其实就是个浅拷贝
   + 通过`builtInComponents`的名字不难看出, 它其实是一个内置组件, 找到源头之后, 可以发现其实内部就是一个`KeepAlive`
   + 所以这里其实就是注册一个全局内置组件, `keep-alive`
   + 实现如下
  ```js
  export function extend (to, _from) {
    // 遍历form对象, 将from中的成员全部以拷贝的方式写入到to对象下(直接拷贝, 如果是引用数据类型的成员, 索引将直接带过来, 也就是说from.xxx.a更新了, 那么to.xxx.a将同步更新)
    for (const key in _from) {
      to[key] = _from[key]
    }
    return to
  }
  ```
8. 调用`initUse(Vue)`注册了`Vue.use`方法, 用于注册插件
9. 调用`initMixin(Vue)`, 注册 `Vue.mixin`方法 用于实现全局混入
10. 调用`initExtend(Vue)`注册 `Vue.extend` 基于传入的options返回一个组件的构造函数
11. 调用`initAssetRegisters(Vue)`注册 `Vue.directive`、`Vue.component` 和 `Vue.filter`方法

### initUse

1. 添加Vue.use静态成员
2. 内部集成了一个用于记录所有已经注册过的组件的数组
3. 如果组件被注册过则直接返回Vue构造函数
4. 如果没有被注册, 则开始注册
5. 首先修改参数为Vue构造函数+use方法接收的除插件以外的其余参数
6. 然后调用插件的install方法或者插件本身(本身就是install方法)
7. 其实install方法本身在定义上, 第一个参数就是Vue构造函数, 而后续参数就是通过Vue.use传入的
8. 记录到installedPlugins数组中表示已注册
9. 返回Vue构造函数(这里是为了链式调用, 如Vue.use(plugin1).use(plugin2))

```js
/**
 * 
 * @param {*} Vue Vue构造函数
 * 用于注册Vue.use静态方法
 */
export function initUse (Vue: GlobalAPI) {
  // 增加一个静态成员use
  Vue.use = function (plugin: Function | Object) {
    // 定义一个常量, 这个常量代表安装的插件
    // 此处的this指向Vue构造函数本身(普通函数, 谁调用指向谁, use方法被Vue构造函数调用, 直接指向Vue构造函数(类))
    // 直接获取构造函数上的_installedPlugins, 如果有的话直接返回, 如果没有就定义出来并且初始化成一个空数组
    // 这个属性就记录了安装的所有插件
    const installedPlugins = (this._installedPlugins || (this._installedPlugins = []))
    // 表示Vue上当前插件注册过, 直接返回
    if (installedPlugins.indexOf(plugin) > -1) {
      return this
    }

    // additional parameters
    // 注册插件过程
    // 去除数组中的第一个元素(插件)
    const args = toArray(arguments, 1)
    // 将Vue构造函数插入到第一个元素的位置
    args.unshift(this)
    // ! 其实下面两个操作就是在做一件事情, 约束install方法的调用格式
    // ! 插件的install方法或者插件本身就是install方法, 他们的第一个参数其实就是Vue构造函数, 而后续参数则是通过Vue.use接收到的除插件本身以外的其余参数
    // 如果插件的install属性存在并且是一个function, 那么直接调用该插件的install方法, this指向当前插件, 参数第一个扩展为Vue构造函数
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args)
    } else if (typeof plugin === 'function') {
      // 如果插件本身就是一个function, 那么直接调用, this指向null, 第一个参数扩展为Vue构造函数
      plugin.apply(null, args)
    }
    // 将插件推送到数组中, 表示已经注册完成
    installedPlugins.push(plugin)
    // 返回Vue构造函数, 便于链式调用
    return this
  }
}
```

### initMixin

用于注册一个mixin静态成员

该静态成员非常简单, 其实就是通过`mergeOptions`将入参(mixin)对象中的所有成员, 拷贝到`Vue.options`这个静态成员上

所以通过Vue.mixin注册的对象是一个全局对象(文档有提到)

```js
export function initMixin (Vue: GlobalAPI) {
  Vue.mixin = function (mixin: Object) {
    // * 可以看到mixin是用来合并options用的
    // * 这里的this是大的Vue, 也就是Vue这个构造函数的this
    // * 这个方法和组件在init时使用的方法一致，只是这样会将全局的mixin中的对象，合并到Vue.prototype.options中
    this.options = mergeOptions(this.options, mixin)
    return this
  }
}
```

### initExtend

内部实现最主要的就是注册一个`Vue.extend`方法

但是该方法比较复杂, 这里只看一下核心功能。

1. 给Vue注册一个静态成员`extend`, 这个方法接收一个参数, 这个参数依然是options, 是一个选项, 也就是组件的选项, 是一个对象
2. 若extendOptions则给默认值为一个空对象(包含原型方法)
3. 缓存Vue构造函数, 赋值给Super
4. 去除Vue.cid赋值给SuperId, 后续拉取缓存时会使用cid进行校验
5. 判断缓存是否存在, 若存在则从缓存中加载组件
6. 定义一个name, 查看组件是否存在name, 如果没有则取全局options上的name, 也就是Vue.options.name
7. 开发环境校验上面的name变量
8. 创建一个`VueComponent`构造函数, 赋值给`Sub`, 这是组件对应的构造函数, 内部调用了组件的`_init`方法
9. `Sub`原型继承Vue构造函数, 这里也说明了所有的子组件, 都是继承自Vue的
```js
// 原型继承
Sub.prototype = Object.create(Super.prototype)
Sub.prototype.constructor = Sub
```
10. 合并选项, 通过mergeOptions合并选线, 将入参的extendOptions和Vue.options(全局选项, 也是基础配置, 这也说明了所有子组件都包含全局的配置)合并
11. 通过`initProps`和`initComputed`初始化子组件的Props和计算属性
12. 将Vue构造函数上的一些静态成员, 拷贝到VueComponent(Sub, 子组件构造函数)这个构造函数上来
13. 初始化子组件的extend、mixin和use方法, 直接拷贝的Vue构造函数上的
14. 注册子组件的component, directive、filter等静态方法(直接拷贝, 这三个方法初始化自`initAssetRegisters`)
15. 如果name存在, 将Sub构造函数记录到`Sub.options.components[name]`上
16. `Sub`用`superOptions`存储Vue.options(全局配置)
17. `Sub`用`extendOptions`存储Vue.extend调时的`extendOptions`
18. `Sub`用`sealedOptions`存储`Sub.options`
19. 将VueComponent写入缓存, 键名为当前cid(自增前的cid, Vue.cid)(每次调用Vue.extend或者子组件的extend方法, cid都会自增一次, cid为闭包中的一个成员, 也是组件的唯一键)
20. 最终返回VueComponent构造函数, 所以Vue.extend返回的就是组件的构造函数, 所以一般用在制作自定义组件时

```js
export function initExtend (Vue: GlobalAPI) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0
  let cid = 1

  /**
   * Class inheritance
   */
  // * extend 传入一个对象，返回是一个函数
  Vue.extend = function (extendOptions: Object): Function {
    extendOptions = extendOptions || {}
    // * extend被Vue构造函数调用, 因此此处的this指向Vue这个构造函数，因为extend是Vue的静态方法，并非原型上的方法
    const Super = this
    // * Vue的cid
    const SuperId = Super.cid
    // * 这里实际上是在extendOptions上增加了一个构造器_Ctor，初始化为一个空对象
    // * 实际上是做了一层缓存的优化, 从缓存中加载组件的构造函数
    // ? 下一次再渲染当前component的时候，如果在Vue上已经存在过这个component，也就会有一个对应的cid存在，那么就会直接取出来，得到该component对应的VNode
    const cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {})
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId]
    }

    // * 定义了一个name, 如果在传过来的对象上不存在这个name，则取Vue.options.name(全局options的name)
    const name = extendOptions.name || Super.options.name
    if (process.env.NODE_ENV !== 'production' && name) {
      // * 如果是开发环境则校验组件名称
      validateComponentName(name)
    }

    // * 定义了一个组件构造函数
    const Sub = function VueComponent (options) {
      // * 所以这里执行this._init时，就会执行Vue.prototype._init方法
      this._init(options)
    }

    // * 原型继承自Vue
    // * 改变了子组件构造函数的原型, 让它的原型指向了Vue.prototype
    Sub.prototype = Object.create(Super.prototype)
    // * 将他原型上的constructor指回自己
    Sub.prototype.constructor = Sub
    //! 以上是一个简单的原型链继承，由于此处super指向Vue，因此Sub完全继承了Vue原型上的所有东西
    // ! 这里也说明了在Vue2.6中所有的组件都是继承自Vue构造函数
    // * cid自增
    Sub.cid = cid++
    // * 合并选项
    // * 通过mergeOptions合并选线, 将入参的extendOptions和Vue.options(全局选项, 也是基础配置, 这也说明了所有子组件都包含全局的配置)合并
    // * 局部注册组件，就会在此处合并选项
    Sub.options = mergeOptions(
      Super.options,
      extendOptions
    )
    // * 然后将super指向外层的Super，也就是Vue
    Sub['super'] = Super

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    // * 以下两个步骤对Sub子构造函数自己的Props和Computed做了一次初始化
    if (Sub.options.props) {
      initProps(Sub)
    }
    if (Sub.options.computed) {
      initComputed(Sub)
    }

    // allow further extension/mixin/plugin usage
    // * 这里将全局(Vue)的静态方法复制给Sub
    Sub.extend = Super.extend
    Sub.mixin = Super.mixin
    Sub.use = Super.use

    // create asset registers, so extended classes
    // can have their private assets too.
    // * 这里拷贝了component, directive和filter
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type]
    })
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options
    Sub.extendOptions = extendOptions
    Sub.sealedOptions = extend({}, Sub.options)

    // cache constructor
    // * 这里将Sub缓存下来，赋值给原来的那个Cid(Sub初始化的时候对原来的cid做了一次+1)
    // * 将组件的构造函数缓存在options._Ctor
    cachedCtors[SuperId] = Sub
    // * 返回组件的构造函数
    return Sub
    // * 这里的目的就是让Sub拥有和Vue一样的能力
  }
}
```
### initAssetRegisters

这里主要注册了三个方法, `component`、`directive`和`filter`

这三个方法为什么可以一起注册?

首先他们的参数几乎是一样的, 其次在使用上也差不多, 因此可以统一处理

1. 遍历`ASSET_TYPES`数组, 注册对应的函数
2. 然后判断是否传递第二个参数, 如果没有传递, 表示获取成员
   + 由于通过三个方法注册的成员, 都会添加到```Vue.options[`${type}`s]```上, 因此获取对应成员, 直接返回```Vue.options[`${type}s][id]```即可
3. 判断当前的type是不是`component`, 如果是, 还要判断第二个参数是不是一个对象(非函数的对象)
   + `isPlainObject`表示是一个普通对象,判断方式为`Object.prototype.toString.call(target)`之后是一个`[object Object]`
4. 如果是, 则设置组件的name, 如果当前组件的options下有给name则直接使用, 如果没有就给Vue.component传入的组件名
5. 然后调用`Vue.options._base.extend(definition)`, 赋值给definition, 将definition转换为一个构造器，extend将会基于Vue初始化一次，增加definition上的配置后返回一个完全继承Vue的构造器
  + `Vue.options._base`前面说过, 就是Vue构造函数, 这里就是调用Vue.extend
  + 因此这里就是将definition制作成一个VueComponent构造函数
  + 所以说如果definition入参就是一个构造函数, 那么这里将不做转换, 直接存储到```this.options[${type}s][name]```中, 并返回name就是入参的一号参数
6. 如果是指令, 有处理方式和component类似
   + 传递的是对象, 则直接存储到`this.options.directives[name]`中
   + 如果是函数的话, 将会生成一个对象, 有两个成员, 一个是bind一个是update, 表示指令在挂载和更新时, 都会执行回调函数中的内容
7. filter特殊操作, 只能传递函数, 直接存储到`this.options.filters[name]`中然后返回

这里也说明了通过 `component` `directive`或者是`filter`方法注册的内容, 都会挂载到`Vue.options[types]`中, 作为全局对象存在

```js
// * 初始化全局静态属性的时候，将会执行initGlobalAPI, 在这个时候，会执行initAssetRegisters，注册三个全局的函数
export function initAssetRegisters (Vue: GlobalAPI) {
  /**
   * Create asset registration methods.
   */
  // 依然是遍历数组ASSET_TYPES, 这下面就包含了component、directive和filter
  ASSET_TYPES.forEach(type => {
    // * 首先将component filter和directive挂载到Vue上
    // * 在这里Vue扩展了三个全局函数， component filter 和 directive
    Vue[type] = function (
      id: string,
      definition: Function | Object
    ): Function | Object | void {
      if (!definition) {
        return this.options[type + 's'][id]
      } else {
        /* istanbul ignore if */
        if (process.env.NODE_ENV !== 'production' && type === 'component') {
          validateComponentName(id)
        }
        // * isPlainObject表示是一个普通对象,判断方式为toString()之后是一个[object Object]
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id
          // * 将definition转换为一个构造器，extend将会基于Vue初始化一次，增加definition上的配置后返回一个完全继承Vue的构造器
          definition = this.options._base.extend(definition)
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition }
        }
        // * 然后在这里将继承自Vue的构造器————definition返回给全局的Vue的options下面的[type]s的id
        // * 这里的type就是component, filter 和 directive

        // * 对于组件注册，就是在Vue.options.components上增加了一个id，这个id就是组件的名字(标签名)，他的属性就是继承自Vue的新的构造器————definition
        this.options[type + 's'][id] = definition
        return definition
      }
    }
  })
}
```

