---
title: Vueç»„ä»¶åŒ–-ç»„ä»¶åˆ›å»ºè¿‡ç¨‹
date: 2022-08-26
tags:
    - vue
categories:
    - Vueæºç 
---

# ç»„ä»¶åˆ›å»ºè¿‡ç¨‹

çœ‹è¿‡äº†ç»„ä»¶çš„æ³¨å†Œè¿‡ç¨‹, å†æ¥çœ‹çœ‹ç»„ä»¶çš„åˆ›å»ºè¿‡ç¨‹

åœ¨è¿™ä¹‹å‰, å…ˆæ¥å›é¡¾ä¸€ä¸‹é¦–æ¬¡æ¸²æŸ“çš„è¿‡ç¨‹

ç‚¹å‡»æ­¤å¤„æŸ¥çœ‹ ğŸ‘‰ğŸ»ğŸ‘‰ğŸ»ğŸ‘‰ğŸ»ğŸ‘‰ğŸ»ğŸ‘‰ğŸ»ğŸ‘‰ğŸ» [è¯¦ç»†æ€»ç»“](/blogs/vue-resource/responsive/5.html#é¦–æ¬¡æ¸²æŸ“è¿‡ç¨‹-æ€»ç»“)

## å›é¡¾é¦–æ¬¡æ¸²æŸ“çš„è¿‡ç¨‹

+ Vueçš„æ„é€ å‡½æ•°
+ this._init()
+ this.$mount()
+ mountComponent()
+ new Watcher() åˆ›å»ºæ¸²æŸ“Watcher
+ updateComponent()
+ vm._render() -> createElement()
+ vm._update()

é¦–å…ˆè°ƒç”¨Vueçš„æ„é€ å‡½æ•°, åœ¨Vueçš„æ„é€ å‡½æ•°ä¸­è°ƒç”¨äº†`this._init()`è¿™ä¸ªæ–¹æ³•, åœ¨_initå‡½æ•°ä¸­, æœ€ç»ˆè°ƒç”¨äº†`this.$mount`, $mountä¸­è°ƒç”¨äº†`mountComponent`, åœ¨mountComponentåˆ›å»ºäº†æ¸²æŸ“Watcher, åˆ›å»ºrenderWatcheræ—¶, ä¼ é€’äº†updateComponent, `åœ¨updateComponentä¸­è°ƒç”¨äº†vm._render`å’Œ`vm._update`, åœ¨vm._renderä¸­è°ƒç”¨äº†ç”¨æˆ·ä¼ å…¥çš„æ¸²æŸ“å‡½æ•°, æˆ–è€…æ˜¯ç¼–è¯‘ç”Ÿæˆçš„æ¸²æŸ“å‡½æ•°ï¼Œ åœ¨æ¸²æŸ“å‡½æ•°ä¸­, é€šè¿‡createElementä¹Ÿå°±æ˜¯hå‡½æ•°åˆ›å»ºäº†VNodeå¯¹è±¡ã€‚

ä¹‹å‰è¯´çš„æ˜¯è°ƒç”¨createElementåˆ›å»ºæ™®é€šHTMLæ ‡ç­¾å¯¹åº”VNodeçš„è¿‡ç¨‹, ä¸‹é¢è¦è§£æçš„æ˜¯è°ƒç”¨createElementåˆ›å»ºç»„ä»¶å¯¹åº”VNodeçš„è¿‡ç¨‹

## è°ƒè¯•ç”¨æ¡ˆä¾‹

è¿™é‡Œä»¥å¦‚ä¸‹æ¡ˆä¾‹åšæ–­ç‚¹è°ƒè¯•æ¥åˆ†æç»„ä»¶åˆ›å»ºçš„è¿‡ç¨‹

```ts
const Comp = Vue.component('comp', {
  template: '<div>Hello Component</div>'
});

const vm = new Vue({
  el: '#app',
  render(h) {
    return h(Comp)
  }
});
```

è°ƒç”¨createElementæ—¶, ä¼ å…¥äº†ç»„ä»¶çš„æ„é€ å‡½æ•°, ä¸‹é¢ä¸»è¦å°±è¦çœ‹åœ¨createElementä¸­æ˜¯å¦‚ä½•å¤„ç†componentsçš„

## createElementä¸»è¦æµç¨‹åŠä»£ç 

> åœ¨createElementä¸­, å’Œå¤„ç†HTMLæ ‡ç­¾ä¸€æ ·, é¦–å…ˆå¤„ç†å‚æ•°, ç„¶åè°ƒç”¨`_createElement`å‡½æ•°
> 
> _createElementå‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯Vueå®ä¾‹æˆ–è€…å½“å‰ç»„ä»¶å®ä¾‹
> 
> ç¬¬äºŒä¸ªå‚æ•°æ ‡ç­¾çš„åå­—, æˆ–è€…ç»„ä»¶, å¯ä»¥ä½¿å­—ç¬¦ä¸², ç±», å‡½æ•°æˆ–ç»„ä»¶é€‰é¡¹å¯¹è±¡
> 
> åé¢æ˜¯åˆ›å»ºVNodeæ—¶éœ€è¦ç”¨åˆ°çš„æ•°æ®ä»¥åŠå„¿å­èŠ‚ç‚¹
> 
> å’Œæ ‡ç­¾ä¸€æ ·, æœ€ç»ˆåˆ›å»ºäº†VNodeèŠ‚ç‚¹
> 
> ç›´æ¥èµ°åˆ°åˆ¤æ–­tagçš„ä½ç½®, åˆ¤æ–­tagæ˜¯å¦ä¸ºå­—ç¬¦ä¸², å¦‚æœä¸æ˜¯å­—ç¬¦ä¸², åˆ™ç›´æ¥è°ƒç”¨[createComponent](/blogs/vue-resource/components/3.html#createcomponent)åˆ›å»ºç»„ä»¶
> 
> å¦‚æœæ˜¯å­—ç¬¦ä¸², ä½†ä¸æ˜¯ä¿ç•™æ ‡ç­¾, åˆ™åˆ¤æ–­æ˜¯å¦å…¨å±€ç»„ä»¶, å¦‚æœæ˜¯, åŒæ ·è°ƒç”¨createComponentåˆ›å»ºç»„ä»¶å®ä¾‹
> 
> é€šè¿‡createComponent, å°†ç»„ä»¶è½¬æ¢æˆäº†å¯¹åº”çš„VNodeå¯¹è±¡

```ts
export function createElement (
  context: Component, // * vmå®ä¾‹æˆ–ç»„ä»¶å®ä¾‹
  tag: any, // * æ ‡ç­¾
  data: any, // * VNodeçš„data
  children: any, // * å­èŠ‚ç‚¹
  normalizationType: any,
  alwaysNormalize: boolean
): VNode | Array<VNode> {
  ...
  // å¤„ç†å®Œå‚æ•°å, è°ƒç”¨_createElementæ–¹æ³•
  return _createElement(context, tag, data, children, normalizationType)
}

export function _createElement (
  context: Component,
  tag?: string | Class<Component> | Function | Object,
  data?: VNodeData,
  children?: any,
  normalizationType?: number
): VNode | Array<VNode> {
  ...
  let vnode, ns
  // åˆ¤è¯»æ ‡ç­¾æ˜¯å¦å­—ç¬¦ä¸², å¦‚æœæ˜¯å­—ç¬¦ä¸²çš„è¯, ä¸€èˆ¬å°±æ˜¯æ™®é€šæ ‡ç­¾
  if (typeof tag === 'string') {
    let Ctor
    ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag)
    if (config.isReservedTag(tag)) {
      // æ™®é€šæ ‡ç­¾å¤„ç†
      ...
    } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // åˆ¤æ–­å½“å‰ä¼ å…¥çš„tagæ˜¯å¦ä¸ºå…¨å±€ç»„ä»¶çš„tag
      vnode = createComponent(Ctor, data, context, children, tag)
    } else {
      ...
    }
  } else {
    // å¦‚æœä¸æ˜¯å­—ç¬¦ä¸², åˆ™ç›´æ¥è°ƒç”¨ createComponent åˆ›å»ºç»„ä»¶VNode
    vnode = createComponent(tag, data, context, children)
  }
  if (Array.isArray(vnode)) {
    return vnode
  } else if (isDef(vnode)) {
    if (isDef(ns)) applyNS(vnode, ns)
    if (isDef(data)) registerDeepBindings(data)
    return vnode
  } else {
    return createEmptyVNode()
  }
}
```

## createComponent

> é¦–å…ˆçœ‹createComponentçš„å‚æ•°
>   + Ctor: ç»„ä»¶ç±», æˆ–è€…å‡½æ•°, æˆ–è€…æ˜¯ä¸€ä¸ªç»„ä»¶çš„é€‰é¡¹å¯¹è±¡, æˆ–è€…å•¥ä¹Ÿæ²¡æœ‰
>   + data: åˆ›å»ºVNodeçš„æ•°æ®
>   + context: vueçš„å®ä¾‹æˆ–å½“å‰ç»„ä»¶å®ä¾‹
>   + children: å­èŠ‚ç‚¹æ•°ç»„æˆ–æ ‡ç­¾åç§°
>   + tag: æ ‡ç­¾å
> 
> è¿›å…¥å‡½æ•°ä¸­, é¦–å…ˆåˆ¤æ–­Ctoræ˜¯å¦å­˜åœ¨, è‹¥ä¸å­˜åœ¨, ç›´æ¥è¿”å›, é€€å‡ºæ‰§è¡Œ, è¯´æ˜å½“å‰tagæœ¬è´¨ä¸Šå¹¶ä¸æ˜¯ä¸€ä¸ªç»„ä»¶
> 
> è·å–contexté€‰é¡¹ä¸­çš„_base, å…¶å®å°±æ˜¯Vueçš„æ„é€ å‡½æ•°, å­˜å‚¨åˆ°`baseCtor`, åé¢ä¼šè®²Vueæ„é€ å‡½æ•°çš„é€‰é¡¹, åˆå¹¶åˆ°ç»„ä»¶å®ä¾‹çš„é€‰é¡¹ä¸­, æ‰€ä»¥è¿™é‡Œå¯ä»¥é€šè¿‡contextä¹Ÿå°±æ˜¯å®ä¾‹çš„é€‰é¡¹æ¥è·å–_base
> 
> æ¥ä¸‹æ¥åˆ¤æ–­Ctoræ˜¯ä¸æ˜¯ä¸€ä¸ªå¯¹è±¡, å¦‚æœä¼ å…¥çš„æ˜¯é€‰é¡¹å¯¹è±¡, è€Œä¸æ˜¯æ„é€ å‡½æ•°, åˆ™è°ƒç”¨[Vue.extend](/blogs/vue-resource/components/2.html#extend)å°†é€‰é¡¹å¯¹è±¡è½¬æ¢ä¸ºç»„ä»¶çš„æ„é€ å‡½æ•°
> 
> ä¸è¿‡ä¸Šè¿°çš„ä¾‹å­ä¸­ä¼ å…¥çš„å°±æ˜¯æ„é€ å‡½æ•°, æ‰€ä»¥ä¸ä¼šæ‰§è¡Œè¿™ä¸ªä½ç½®
> 
> æ¥ä¸‹æ¥åšä¸€å±‚é”™è¯¯æ‹¦æˆª, é˜²æ­¢æœ‰å…¶ä»–å¼‚å¸¸å¯¼è‡´æ²¡æœ‰è½¬æ¢æˆæ„é€ å‡½æ•°çš„ç»„ä»¶ç»§ç»­å¾€ä¸‹æ‰§è¡Œ, å¹¶åœ¨å¼€å‘ç¯å¢ƒå‘Šè­¦
> 
> æ¥ç€æ˜¯å¤„ç†å¼‚æ­¥ç»„ä»¶, å¦‚æœCtorä¸Šæ²¡æœ‰cid, å°±è®¤ä¸ºæ˜¯å¼‚æ­¥ç»„ä»¶(åŒæ­¥ç»„ä»¶çš„æ„é€ å‡½æ•°ä¸­æ˜¯ä¸€å®šæœ‰cidçš„, åœ¨extendä¸­çœ‹åˆ°è¿‡)
> 
> æ¥ç€æ˜¯å¤„ç†data, é˜²æ­¢å¼‚å¸¸dataå‡ºç°
> 
> åˆå¹¶é€‰é¡¹, å½“ç»„ä»¶æ„é€ å‡½æ•°åˆ›å»ºå®Œæ¯•å, åˆå¹¶å½“å‰ç»„ä»¶çš„é€‰é¡¹å’Œé€šè¿‡Vue.mixinæ··å…¥çš„é€‰é¡¹, è°ƒç”¨[resolveConstructorOptions](/blogs/vue-resource/components/3.html#resolveconstructoroptions)
> 
> å¤„ç†ç»„ä»¶çš„v-modelæŒ‡ä»¤
> 
> æå–props
> 
> å¤„ç†å‡½æ•°å¼ç»„ä»¶
> 
> æ¥ä¸‹æ¥å¤„ç†è‡ªå®šä¹‰äº‹ä»¶
> 
> ç„¶åæ˜¯é€šè¿‡[installComponentHooks(data)](/blogs/vue-resource/components/3.html#resolveconstructoroptions)å®‰è£…ç»„ä»¶çš„é’©å­å‡½æ•°, ç»„ä»¶ä¸­é»˜è®¤çš„é’©å­å‡½æ•°æœ‰å››ä¸ª: init/prepatch/insert/destroyã€‚
> 
> å†å¾€ä¸‹ä¼šè·å–ç»„ä»¶çš„åç§°, èµ‹å€¼ç»™name
> 
> ç„¶ååˆ›å»ºè‡ªå®šä¹‰ç»„ä»¶çš„VNodeå¹¶è®¾ç½®è‡ªå®šä¹‰ç»„ä»¶çš„åå­—
  ```ts
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  )
  ```
> 
> ç»„ä»¶çš„åå­—å°±æ˜¯ä»¥`vue-component-`ä½œä¸ºå‰ç¼€, ç„¶åæ‹¼æ¥ä¸Š`cid`, å¦‚æœæœ‰name, åœ¨æ‹¼æ¥ä¸Šname
> 
> æ¥ç€ä¼ å…¥data, ç„¶åä¸‰ä¸ªå‚æ•°éƒ½æ˜¯undefined, ä¼ å…¥contextå’Œä¸€ä¸ªå¯¹è±¡
> 
> è¿›å…¥[VNode](/blogs/vue-resource/virtualDOM/4.html#vnode)çš„æ„é€ å‡½æ•°
> 
> å¯ä»¥çœ‹åˆ°`children, text, å’Œelm`éƒ½æ˜¯undefined
> 
> contextæ˜¯ç»„ä»¶å®ä¾‹
> 
> ç„¶åæ˜¯componentOptions, è¿™ä¸ªå°±æ˜¯åœ¨`createComponentInstanceForVnode`ä¸­æœ€åæ‰€ä½¿ç”¨åˆ°çš„é‚£ä¸ª`componentOptions`, ä¹Ÿå°±æ˜¯`{ Ctor, propsData, listeners, tag, children }`è¿™ä¸ªå¯¹è±¡
> 
> componentOptionsä¸­çš„Ctorå‡½æ•°, å°±æ˜¯è®°å½•çš„ç»„ä»¶çš„æ„é€ å‡½æ•°, ä»–åœ¨[createComponentInstanceForVnode](/blogs/vue-resource/components/3.html#createcomponentinstanceforvnode)ä¸­é€šè¿‡`new vnode.componentOptions.Ctor(options)`æ¥åˆ›å»ºçš„ç»„ä»¶å¯¹è±¡
> 
> æœ€åè¿”å›vnodeå¯¹è±¡
> 
> createComponentæœ€ç»ˆæŠŠç»„ä»¶è½¬æ¢æˆå“¼äº†vnodeå¯¹è±¡

```ts
/**
 * 
 * @param {*} Ctor // ! æ˜¯ä¸€ä¸ªç»„ä»¶ç±»å‹çš„ç±»ï¼Œä¹Ÿå¯ä»¥æ˜¯å‡½æ•°ï¼Œå¯¹è±¡ï¼Œä¹Ÿå¯ä»¥æ˜¯ç©ºç±»å‹
 * @param {*} data // ! åˆ›å»ºVNodeçš„æ•°æ®
 * @param {*} context // ! ä¹Ÿå°±æ˜¯å½“å‰vmå®ä¾‹
 * @param {*} children // ! å„¿å­ç»„ä»¶VNode
 * @param {*} tag // ! æ ‡ç­¾
 */
export function createComponent (
  Ctor: Class<Component> | Function | Object | void,
  data: ?VNodeData,
  context: Component,
  children: ?Array<VNode>,
  tag?: string
): VNode | Array<VNode> | void {
  if (isUndef(Ctor)) {
    return
  }

  const baseCtor = context.$options._base

  // plain options object: turn it into a constructor
  // å¦‚æœctorä¸æ˜¯ä¸€ä¸ªå‡½æ•°, æ˜¯ä¸€ä¸ªå¯¹è±¡
  // ä½¿ç”¨ Vue.extend() åˆ›å»ºä¸€ä¸ªå­ç»„ä»¶çš„æ„é€ å‡½æ•°
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor)
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  // æ‹¦æˆªä¸€æ¬¡é”™è¯¯, é˜²æ­¢æ„å¤–
  if (typeof Ctor !== 'function') {
    if (process.env.NODE_ENV !== 'production') {
      warn(`Invalid Component definition: ${String(Ctor)}`, context)
    }
    return
  }

  // å¤„ç†å¼‚æ­¥ç»„ä»¶
  let asyncFactory
  // Ctorä¸Šæ²¡æœ‰cid, æˆ‘ä»¬å°±è®¤ä¸ºæ˜¯å¼‚æ­¥ç»„ä»¶
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor)
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(
        asyncFactory,
        data,
        context,
        children,
        tag
      )
    }
  }

  // å¤„ç†data, é˜²æ­¢dataä¸ºundefinedæˆ–è€…null
  data = data || {}

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  // å½“ç»„ä»¶æ„é€ å‡½æ•°åˆ›å»ºå®Œæ¯•å, åˆå¹¶å½“å‰ç»„ä»¶çš„é€‰é¡¹å’Œé€šè¿‡Vue.mixinæ··å…¥çš„é€‰é¡¹
  resolveConstructorOptions(Ctor)

  // transform component v-model data into props & events
  // å¤„ç†v-modelæŒ‡ä»¤
  if (isDef(data.model)) {
    transformModel(Ctor.options, data)
  }

  // extract props
  // æå–props
  const propsData = extractPropsFromVNodeData(data, Ctor, tag)

  // functional component å‡½æ•°ç»„ä»¶
  // å¤„ç†å‡½æ•°ç»„ä»¶
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children)
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  // * å¤„ç†è‡ªå®šä¹‰äº‹ä»¶
  const listeners = data.on
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    const slot = data.slot
    data = {}
    if (slot) {
      data.slot = slot
    }
  }

  // install component management hooks onto the placeholder node
  // å®‰è£…ç»„ä»¶çš„é’©å­å‡½æ•°: /init/prepatch/insert/destroy
  // å‡†å¤‡å¥½äº† data.hook ä¸­çš„é’©å­å‡½æ•°
  installComponentHooks(data)

  // return a placeholder vnode
  // è·å–ç»„ä»¶çš„åç§°, èµ‹å€¼ç»™name
  const name = Ctor.options.name || tag
  // åˆ›å»ºè‡ªå®šä¹‰ç»„ä»¶çš„VNodeDataï¼Œ è®¾ç½®è‡ªå®šä¹‰ç»„ä»¶çš„åå­—
  // è®°å½• this.componentOptions = componentOptions
  const vnode = new VNode(
    `vue-component-${Ctor.cid}${name ? `-${name}` : ''}`,
    data, undefined, undefined, undefined, context,
    { Ctor, propsData, listeners, tag, children },
    asyncFactory
  )

  // Weex specific: invoke recycle-list optimized @render function for
  // extracting cell-slot template.
  // https://github.com/Hanks10100/weex-native-directive/tree/master/component
  /* istanbul ignore if */
  if (__WEEX__ && isRecyclableComponent(vnode)) {
    return renderRecyclableComponentTemplate(vnode)
  }

  return vnode
}
```

### createComponentå°ç»“

1. åœ¨è¿™ä¸ªå‡½æ•°å†…éƒ¨, çœ‹åˆ°äº†å…¶åˆå§‹åŒ–äº†å››ä¸ªé’©å­å‡½æ•°
2. æœ€ç»ˆè¿”å›äº†ç»„ä»¶çš„vnode(å ä½èŠ‚ç‚¹, æ ‡ç­¾vnode, å¹¶éç»„ä»¶æœ¬èº«)
3. åœ¨inité’©å­å‡½æ•°ä¸­åˆ›å»ºäº†ç»„ä»¶å¯¹è±¡çš„å®ä¾‹
4. è€Œinité’©å­å‡½æ•°, å®åœ¨patchçš„è¿‡ç¨‹ä¸­è°ƒç”¨çš„, è¿™ä¸ªç¨åæ¥çœ‹

## resolveConstructorOptions
```ts
export function resolveConstructorOptions (Ctor: Class<Component>) {
  // * åˆå§‹åŒ–çš„æ—¶å€™ä¼ å…¥çš„Ctoræ˜¯Vueæ„é€ å‡½æ•°(Vue)(æˆ–è€…æ˜¯ç»„ä»¶çš„æ„é€ å™¨ï¼Œå½“ç„¶ä¹Ÿæ˜¯mergeäº†Vueçš„åŸºæœ¬æ–¹æ³•å’ŒåŸå‹æ–¹æ³•)
  let options = Ctor.options
  if (Ctor.super) {
    // * åœ¨Ctoræ˜¯Vueæ„é€ å‡½æ•°çš„æ—¶å€™ï¼Œä¸Šé¢ä¸å­˜åœ¨superï¼Œå› æ­¤ä¸ä¼šèµ°å…¥è¿™é‡Œé¢
    // * ç»„ä»¶åŠ è½½ï¼Œæ— è®ºæ˜¯å¼‚æ­¥è¿˜æ˜¯åŒæ­¥ï¼Œåœ¨Ctorä¸Šï¼Œéƒ½å­˜åœ¨superï¼ŒæŒ‡å‘çš„æ˜¯ä¸Šä¸€å±‚çš„super, ä¹Ÿå°±æ˜¯Vueæ„é€ å‡½æ•°
    const superOptions = resolveConstructorOptions(Ctor.super)
    // ! Ctor.superOptionså°±æ˜¯å¤–å±‚çš„options
    const cachedSuperOptions = Ctor.superOptions
    if (superOptions !== cachedSuperOptions) {
      // * è¿™é‡Œçš„é€»è¾‘ï¼Œåªæœ‰åœ¨resolveConstructorOptionsæ–¹æ³•ä¼ å…¥çš„Ctor.superä¸ºVueçš„æ—¶å€™æ‰ä¼šè¿›æ¥
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions
      // check if there are any late-modified/attached options (#4976)
      const modifiedOptions = resolveModifiedOptions(Ctor)
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions)
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions)
      if (options.name) {
        options.components[options.name] = Ctor
      }
    }
  }
  // * ç›¸å½“äºè¿™é‡Œè·å–çš„æ˜¯Vueæ„é€ å‡½æ•°ä¸Šçš„ä¸€ä¸ªåŸºæœ¬options, ç„¶åä¼šå°†è¿™ä¸ªoptionsåˆå¹¶åˆ°å…¨å±€æ³¨å†Œç»„ä»¶çš„optionsä¸Šé¢å»
  return options
}
```

## installComponentHooks

> åœ¨è¿™é‡Œé¢é¦–å…ˆè·å–data.hook, ä¹Ÿå°±æ˜¯ç”¨æˆ·ä¼ å…¥çš„ç»„ä»¶çš„é’©å­å‡½æ•°
> 
> ç„¶åéå† hooksToMerge, å†…éƒ¨å°±æ˜¯['init', 'prepatch', 'insert', 'destroy']
>    + hooksToMergeå°±æ˜¯è·å–[componentVNodeHooks](/blogs/vue-resource/components/3.html#componentvnodehooks)è¿™ä¸ªå¯¹è±¡çš„é”®
>   
> åœ¨éå†è¿‡ç¨‹ä¸­, å°†ç”¨æˆ·ä¼ å…¥çš„é’©å­`existing`å’ŒcomponentVNodeHooksä¸­é¢„å®šä¹‰çš„é’©å­`toMerge`ä½œå¯¹æ¯”, å¦‚æœä»–ä¿©ä¸ç­‰, å¹¶ä¸”æ²¡æœ‰åˆå¹¶è¿‡, åˆ™éœ€è¦æ‰§è¡Œåˆå¹¶æ“ä½œ
> 
> åˆå¹¶æ“ä½œå…¶å®å°±æ˜¯æŸ¥çœ‹å½“å‰ç”¨æˆ·æ˜¯å¦ä¼ å…¥å¯¹åº”çš„hook, å¦‚æœæœ‰, åˆ™è°ƒç”¨[mergeHook(toMerge, existing)](/blogs/vue-resource/components/3.html#mergehook), ç„¶åç”¨`hooks[key]`æ¥æ”¶
> 

```ts
// hooksToMergeå®é™…ä¸Šå°±æ˜¯ init/prepatch/insert/destroy
const hooksToMerge = Object.keys(componentVNodeHooks)

function installComponentHooks (data: VNodeData) {
  // * è·å–ç”¨æˆ·ä¼ å…¥çš„ç»„ä»¶çš„hook
  const hooks = data.hook || (data.hook = {})
  // ç”¨æˆ·å¯ä»¥ä¼ é€’è‡ªå®šä¹‰é’©å­å‡½æ•°
  // æŠŠç”¨æˆ·ä¼ å…¥çš„è‡ªå®šä¹‰é’©å­å‡½æ•°å’Œ componentVNodeHooks ä¸­é¢„å®šä¹‰çš„é’©å­å‡½æ•°åˆå¹¶
  for (let i = 0; i < hooksToMerge.length; i++) {
    const key = hooksToMerge[i]
    const existing = hooks[key]
    const toMerge = componentVNodeHooks[key]
    if (existing !== toMerge && !(existing && existing._merged)) {
      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge
    }
  }
}
```

## componentVNodeHooks

> ç»„ä»¶å¯¹è±¡çœŸæ­£åˆ›å»ºçš„ä½ç½®å°±æ˜¯åœ¨inité’©å­å‡½æ•°ä¸­
> 
> é¦–å…ˆåˆ¤æ–­å½“å‰ç»„ä»¶æ˜¯å¦è¢«ç¼“å­˜, å¦‚æœå­˜åœ¨ç»„ä»¶å®ä¾‹ä¸”æ²¡æœ‰è¢«é”€æ¯, åŒæ—¶é€‰é¡¹ä¸­æœ‰keepAlive, è¯´æ˜éœ€è¦æ‰§è¡Œç¼“å­˜, ä¸éœ€è¦é‡æ–°åˆ›å»ºç»„ä»¶, ç›´æ¥è°ƒç”¨prepatchå³å¯
> 
> åœ¨ else è¯­å¥å—ä¸­æ‰æ˜¯çœŸæ­£çš„åˆ›å»ºç»„ä»¶çš„å®ä¾‹, é€šè¿‡è°ƒç”¨[createComponentInstanceForVnode(vnode, activeInstance)](/blogs/vue-resource/components/3.html#createcomponentinstanceforvnode)
> 
> ä¸Šé¢è¿™ä¸ªactiveInstanceå°±ä»£è¡¨å½“å‰ç»„ä»¶æ ‡ç­¾çš„vmå®ä¾‹(å…¶å®å°±æ˜¯å½“å‰ç»„ä»¶çš„çˆ¹)ï¼Œç­‰__patch__æ‰§è¡Œå®Œæ¯•åï¼ŒactiveInstanceå°±ä¼šæ¸…ç©ºå˜ä¸ºnull

```ts
const componentVNodeHooks = {
  init (vnode: VNodeWithData, hydrating: boolean): ?boolean {
    // * å¦‚æœdataä¸‹é¢æœ‰keepaliveï¼Œåˆ™èµ°ä¸‹é¢çš„é€»è¾‘
    if (
      vnode.componentInstance &&
      !vnode.componentInstance._isDestroyed &&
      vnode.data.keepAlive
    ) {
      // å¤„ç†keepAlive
      // kept-alive components, treat as a patch
      const mountedNode: any = vnode // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode)
    } else {
      // * ç»„ä»¶åˆ›å»ºè¿‡ç¨‹ä¸­ï¼ŒactiveInstanceå°±ä»£è¡¨å½“å‰å±‚çº§çš„vmå®ä¾‹ï¼Œç­‰__patch__æ‰§è¡Œå®Œæ¯•åï¼ŒactiveInstanceå°±ä¼šæ¸…ç©ºå˜ä¸ºnull
      const child = vnode.componentInstance = createComponentInstanceForVnode(
        vnode,
        activeInstance
      )
      // * ç„¶åè¿™é‡Œæ‰‹åŠ¨è°ƒç”¨å­ç»„ä»¶å®ä¾‹ä¸Šçš„$mountæ–¹æ³•
      child.$mount(hydrating ? vnode.elm : undefined, hydrating)
    }
  },

  prepatch (oldVnode: MountedComponentVNode, vnode: MountedComponentVNode) {
    const options = vnode.componentOptions
    const child = vnode.componentInstance = oldVnode.componentInstance
    updateChildComponent(
      child,
      options.propsData, // updated props
      options.listeners, // updated listeners
      vnode, // new parent vnode
      options.children // new children
    )
  },

  insert (vnode: MountedComponentVNode) {
    const { context, componentInstance } = vnode
    if (!componentInstance._isMounted) {
      // * æ‰§è¡Œå®Œäº†insertï¼Œæ‰ä¼šæŠŠ_isMountedè®¾ç½®ä¸ºtrue
      // * ä¹Ÿå°±æ˜¯è¯´ï¼Œé¦–æ¬¡æ¸²æŸ“ï¼Œåªä¼šæ‰§è¡Œmountedï¼Œå½“å†æ¬¡å»æ›´æ–°ï¼Œé‡æ–°æ¸²æŸ“ï¼Œæ‰ä¼šæ‰§è¡Œupdated
      componentInstance._isMounted = true
      callHook(componentInstance, 'mounted')
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance)
      } else {
        activateChildComponent(componentInstance, true /* direct */)
      }
    }
  },

  destroy (vnode: MountedComponentVNode) {
    const { componentInstance } = vnode
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy()
      } else {
        deactivateChildComponent(componentInstance, true /* direct */)
      }
    }
  }
}
```

## mergeHook

> åˆ›å»ºä¸€ä¸ªæ–°çš„å‡½æ•°merged, æ¥æ”¶ä¸¤ä¸ªå‚æ•°, å…¶å®ä»£è¡¨çš„å°±æ˜¯åŸæ¥å‡½æ•°çš„å‚æ•°, æœ€å¤šæœ‰ä¸¤ä¸ª, è¿™é‡Œç›¸å½“äºå…¨éƒ¨æ¥æ”¶
> 
> åœ¨æ–°çš„å‡½æ•°å†…éƒ¨, å…ˆæ‰§è¡Œé¢„å®šä¹‰çš„é’©å­å‡½æ•°, åœ¨æ‰§è¡Œç”¨æˆ·ä¼ å…¥çš„é’©å­å‡½æ•°
> 
> å°†_mergedæ ‡è¯†ä¸ºtrue, ä¹Ÿå°±æ˜¯æ ‡è¯†å·²åˆå¹¶, è¿”å›æ–°çš„å‡½æ•°

```ts
function mergeHook (f1: any, f2: any): Function {
  const merged = (a, b) => {
    // flow complains about extra args which is why we use any
    f1(a, b)
    f2(a, b)
  }
  merged._merged = true
  return merged
}
```

## createComponentInstanceForVnode

> createComponentInstanceForVnodeä¸»è¦ç”¨äºåˆ›å»ºç»„ä»¶å®ä¾‹
> 
> parentæ˜¯ç»„ä»¶çš„çˆ¹çš„vmå®ä¾‹, vnodeæ˜¯å ä½ç¬¦
> 
> å®šä¹‰ä¸€ä¸ªoptions
> 
> å¤„ç† inline-template
> 
> æœ€åæ‰æ˜¯æ ¸å¿ƒ, è°ƒç”¨`new vnode.componentOptions.Ctor(options)`åˆ›å»ºç»„ä»¶å®ä¾‹
> 
> è¿™ä¸ª componentOptions.Ctorå…¶å®å°±æ˜¯ç»„ä»¶çš„æ„é€ å‡½æ•°, ä¼ å…¥äº† options
> 
> ä¸Šé¢å¯ä»¥çœ‹åˆ°componentOptionsçš„åˆå§‹åŒ–è¿‡ç¨‹


```ts
export function createComponentInstanceForVnode (
  vnode: any, // we know it's MountedComponentVNode but flow doesn't
  parent: any // activeInstance in lifecycle state
): Component {
  const options: InternalComponentOptions = {
    _isComponent: true,
    _parentVnode: vnode, // * å ä½ç¬¦VNode
    parent
  }
  // check inline-template render functions
  // è·å– inline-template
  // <comp inline-template>xxx</comp>
  const inlineTemplate = vnode.data.inlineTemplate
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render
    options.staticRenderFns = inlineTemplate.staticRenderFns
  }
  // åˆ›å»ºç»„ä»¶å®ä¾‹
  return new vnode.componentOptions.Ctor(options)
}
```

