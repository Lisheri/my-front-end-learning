---
title: 懒加载源码分析
date: 2021-07-21
tags:
 - webpack
categories: 
 - webpack源码解析
---

# 懒加载源码分析

## 过程分析

> 1. 首先从上到下定义一系列的函数及其静态成员
> 
> 2. `__webpack_modules__`webpack5.x主要bundle内部定义的模块
> 
> 3. `__webpack_module_cache__`模块缓存
> 
> 4. `__webpack_require__`模块加载方法
> 
> 5. `__webpack_require__.m = __webpack_modules__;`静态成员m, 指向主要bundle下的模块定义对象(生产环境下是数组)
> 
> 6. `__webpack_require__.d`, 通过一个IIFE生成一个函数作用域(做私有作用域), 包裹生成新的静态成员d, 用于为exports导出成员添加getter
> 
> 7. 利用一个新的IIFE, 定义两个静态成员, `__webpack_require__.f = {};`, 用于保存一些加载模块的Promise方法, 但是此时, 他还是一个空数组
> 
> 8. `__webpack_require__.e`, 也就是按需加载核心所在, 替换了我们的`import('xxx')`方法, 内部就是使用Promise.all去执行`__webpack_require__.f`这个函数下面一系列的函数, 用于扩充一个参数 `promises`数组, 最终这个Promise.all执行的就是这个`promises`数组下的一系列promise, 返回的就是按需加载的模块内容
> 
> 9. `__webpack_require__.u`, 静态成员u, 作用是获取 魔法注释在webpack打包后单独生成的bundle
> 
> 10. `__webpack_require__.o`, 定义静态成员o, 用于判断一号参数自身属性中是否存在二号参数这个属性
> 
> 11. `__webpack_require__.l`静态成员l, 是一个通过模块id生成script标签的 script加载函数, 在静态成员f中的j方法中触发
> 
> 12. `__webpack_require__.r`, 静态成员r, 为所有的导出成员打上ES Module标记
> 
> 13. `__webpack_require__.p`, 定义静态成员p, 代表publicPath, 注意, 按需加载时, 5.x也不会去推导publicPath, 必须存在一个非按需的模块加载
> 
> 14. `__webpack_require__.f.j`, j方法, 主要用于扩充promises, 这个在o方法的Promise.all中执行的主要promise数组
> 
> 15. `webpackJsonpCallback`, 在模块按需加载时, 用于添加Script标签的回调函数(JSONP就是利用script标签的src属性)
> 
> 16. 下面的这里主要是扩展了chunkLoadingGlobal.push方法, 结合到了webpackJsonpCallback上, 并且将webpackJsonpCallback的第一个参数修改为了最初的push
```js
var chunkLoadingGlobal = self["webpackChunk_01_clean_webpack"] = self["webpackChunk_01_clean_webpack"] || [];
    // * 首次走到这里的时候, 这个chunkLoadingGlobal是一个空数组, 因此并不会进去
    // * 当然, 如果存在一个直接加载但是又单独拆分的模块, 他是会进去的
 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
    // * 主要是为了扩充push操作, 将chunkLoadingGlobal.push方法指向webpackJsonpCallback
    // * 并且在webpackJsonpCallback入参时, 拿到的parentChunkLoadingFunction是最初的push方法
 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
```
> 
> 17. 单独打包成bundle的模块如下所示
> 这一段push在按需加载的时候才会执行, 初始化时, 并不会执行
> 因此这里执行push的时候, 由于chunkLoadingGlobal是直接拷贝的`self["webpackChunk_01_clean_webpack"]`
> 因此此处执行push的时候就是执行的扩充后的push函数, 也就是webpackJsonpCallback
> 因此这里push的入参, 就成了webpackJsonpCallback的第二个参数, `data`
> 也就是说上述的webpackJsonpCallback, 定义过后在没有直接加载单独分包模块的情况下, 首次执行, 就是在此处
> 

```js
(self["webpackChunk_01_clean_webpack"] = self["webpackChunk_01_clean_webpack"] || []).push([["fuck"], {
 "./src/a.js":
/*!******************!*\
  !*** ./src/a.js ***!
  \******************/
 ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {
"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "name": () => (/* binding */ name),
/* harmony export */   "fuck": () => (/* binding */ fuck)
/* harmony export */ });
// module.exports = {
//   name: "name",
//   fuck: 'cao'
// }
const name = 'name';
const fuck = 'cao';
 })
}]);
```

> 18. 而上述模块的加载, 依赖于`__webpack_require__.e`去触发静态成员f下面的j, 再来触发这个push, 拿到单独打包的模块
> 
> 19. 而e方法的也就是我们在源代码中所定义的模块按需加载中的import, 一切, 回到了最开始, 将上面的所有链接。
> 
> 20. 额外说一下对魔法注释的处理, webpack会集成一个`模块对象数组`, 他的集成方式就是在单独的`bundle`和`主要bundle`中都定义一个`self["webpackChunk_项目名"]`这样的一个数组, 如果不存在, 那么初始化为空数组, 而在单独拆分出来的`bundle`中这么一句, 就是将单独拆分的模块push到这个数组中, `self`代表的就是全局对象, 一般就是`window`。
> 
> 注: 这是一个二维数组, 二维数组中第二维的第一个成员也是一个数组, 内部是一个模块的名字, 是一个字符串
> 
> 第二个成员才是当前模块
> 
> 模块定义的方式和以往一样, 主要的bundle中就是`__webpack_modules__`, 然后其他的模块就在`self["webpackChunk_项目名"]`中
> 
> + 如果是ES Module, 那么就是`__webpack_require__`方法
> + 如果是CommonJS, 那么就是`__webpack_require__.t`方法
> 
> 使用上述方法加载模块后将会得到一个包含模块导出内容的对象, 作为当前then中第一个回调函数的返回结果
> 
> 也就是模拟了`import('xxx').then(res => {...})`, 这个res就是上面回调函数的返回结果
> 

### 到此为止, webpack5.x的模块按需加载(懒加载)梳理完成, 后续在继续分析 f.j方法 和 l方法
