---
title: SyncHook 源码分析
date: 2021-07-27
tags:
  - webpack
  - webpackSource
categories:
  - webpack源码解析
---

# SyncHook 源码分析

## 如下代码执行过程分析

```js
const { SyncHook } = require("tapable");

const hook = new SyncHook(["name", "age"]); // 参数数组, 表示回调函数中的参数

hook.tap("fn1", (name, age) => {
  console.info("fn1--->", name, age);
});

hook.tap("fn2", (name, age) => {
  console.info("fn2--->", name, age);
});

hook.tap("fn3", (name, age) => {
  console.info("fn3--->", name, age);
});

hook.call("mhe", 120);
```

## `new SyncHook(['name', 'age'])`

```js
function SyncHook(args = [], name = undefined) {
  const hook = new Hook(args, name);
  hook.constructor = SyncHook;
  hook.tapAsync = TAP_ASYNC;
  hook.tapPromise = TAP_PROMISE;
  hook.compile = COMPILE;
  return hook;
}
```

执行 `new SyncHook(['name', 'age'])`就是执行了上面的`SyncHook`构造函数

ages 就是我们传递的数组`['name', 'age']`, 这也就是注释中所写的参数数组, 默认值是一个空数组, 当然, 这里并没有传递`name`

### `new Hook(args, name)`

如下所示

```js
const Hook = require("./Hook");
```

在`SyncHook.js`这个文件中, 有上述一行代码, 其实说白了, 这个 Hook, 就是所有 Hook 的一个父类, 是他们的祖宗(基类)

当然, 在继承的过程中, 有些东西需要重写, 比如`TAP_ASYNC`

### factory

接下来就是这个 factory, 也就是专门用于生成代码的, 所谓的生成代码的一个工厂(工厂模式)

```js
const HookCodeFactory = require("./HookCodeFactory");

class SyncHookCodeFactory extends HookCodeFactory {
  content({ onError, onDone, rethrowIfPossible }) {
    return this.callTapsSeries({
      onError: (i, err) => onError(err),
      onDone,
      rethrowIfPossible,
    });
  }
}

const factory = new SyncHookCodeFactory();
```

在上述代码中, 也有一个基类 -> `HookCodeFactory`, 在不同的钩子中, 都需要继承这个基类, 然后去重写一些适配自己的方法

然后这类实例化了一个`factory`对象

### 重写 Hook 中的如下方法

```js
const TAP_ASYNC = () => {
  throw new Error("tapAsync is not supported on a SyncHook");
};

const TAP_PROMISE = () => {
  throw new Error("tapPromise is not supported on a SyncHook");
};

const COMPILE = function(options) {
  factory.setup(this, options);
  return factory.create(options);
};
```

这里的`TAP_ASYNC`, `TAP_PROMISE`和`COMPILE`就是重写的三个方法, 在实例化 SyncHook 时执行

> 其实这里很好理解, 因为`tapAsync`和`tapPromise`都是异步钩子的方法, 而同步钩子没有这个方法, 因此这里走进去就是报错, 很常规的操作

所以这里在一步说明了, hook 就是一个基类, 很多方法, 需要根据实际情况重写

## Hook.js 分析

### Hook 类的构造器

```js
...
class Hook {
	constructor(args = [], name = undefined) {
		this._args = args;
		this.name = name;
		this.taps = [];
		this.interceptors = [];
		this._call = CALL_DELEGATE;
		this.call = CALL_DELEGATE;
		this._callAsync = CALL_ASYNC_DELEGATE;
		this.callAsync = CALL_ASYNC_DELEGATE;
		this._promise = PROMISE_DELEGATE;
		this.promise = PROMISE_DELEGATE;
		this._x = undefined;

		this.compile = this.compile;
		this.tap = this.tap;
		this.tapAsync = this.tapAsync;
		this.tapPromise = this.tapPromise;
	}
  ...
}

module.exports = Hook;
```

首先进入的是`constructor`, Hook 的构造器, 上面执行`new Hook(args, name)`, 就会进入其中

`args`就是传入的参数数组, `name`没有, 就是 undefined

这里的`this`指向的 hook 实例, 也就是在 syncHook 中的`hook`, 而这个构造器, 最主要的作用就是往实例身上挂载属性, 用于做一个初始化操作

首先给的就是`_args`和`name`

而这个`taps`, 就是每一次执行 tap 之后, 就会往里面丢东西, 具体丢什么, 之前说过, 主要存储的成员是每一次 tap 过后的回调函数, 默认是一个空数组

接下来初始化`interceptors`, 专门用于处理拦截器, 这里暂时用不到, 后面说

`_call 和 call`方法, 就是上面提供好的一个常量, 常量定义如下:

具体的分析其实上一节说过

```js
const CALL_DELEGATE = function(...args) {
  this.call = this._createCall("sync");
  return this.call(...args);
};
```

接下来也没有什么说的了, `_callAsync` 和 `promise` 都是触发被监听回调函数的方法

`_x`将在后续被扩展, 主要是将 taps 中的回调函数单独取出来作成员

接下来就是挂载下面的方法, 后面遇到了细说, 这里仅做挂载

```js
class Hook {
...
compile(options) {
		throw new Error("Abstract: should be overridden");
	}

	_createCall(type) {
		return this.compile({
			taps: this.taps,
			interceptors: this.interceptors,
			args: this._args,
			type: type
		});
	}

	_tap(type, options, fn) {
		if (typeof options === "string") {
			options = {
				name: options.trim()
			};
		} else if (typeof options !== "object" || options === null) {
			throw new Error("Invalid tap options");
		}
		if (typeof options.name !== "string" || options.name === "") {
			throw new Error("Missing name for tap");
		}
		if (typeof options.context !== "undefined") {
			deprecateContext();
		}
		options = Object.assign({ type, fn }, options);
		options = this._runRegisterInterceptors(options);
		this._insert(options);
	}

	tap(options, fn) {
		this._tap("sync", options, fn);
	}

	tapAsync(options, fn) {
		this._tap("async", options, fn);
	}

	tapPromise(options, fn) {
		this._tap("promise", options, fn);
	}

	_runRegisterInterceptors(options) {
		for (const interceptor of this.interceptors) {
			if (interceptor.register) {
				const newOptions = interceptor.register(options);
				if (newOptions !== undefined) {
					options = newOptions;
				}
			}
		}
		return options;
	}
}
...
```

## `new SyncHook(['name', 'age'])`续

```js
function SyncHook(args = [], name = undefined) {
  const hook = new Hook(args, name);
  hook.constructor = SyncHook;
  hook.tapAsync = TAP_ASYNC;
  hook.tapPromise = TAP_PROMISE;
  hook.compile = COMPILE;
  return hook;
}
```

上面说了 `new Hook`, 接下来就是将当前的 hook 实例的构造器指向构造函数`SyncHook`本身

其实主要就是做了一个基本的实例继承

hook 作为一个基类, 将需要使用的或者不需要使用的其实都提供好了, 但是子类又不需要这些能力, 因此就需要砍一刀 或者 重写一个适合自己的, 比如下面几个方法

`tapAsync`, `tapPromise`这俩是典型, 这样在使用`SyncHook`的实例, 去调用`tapAsync`, 就会抛错

然后挂载`COMPILE`

然后就返回了`hook`, 也就是 new 出来的 SyncHook 的实例

## 总结

上面说了一大堆, 其实就是实例化了一个`SyncHook`的实例对象

- 实例对象有一个`hook类`, `SyncHookCodeFactory 代码工厂类`然后才是自己的 `SyncHook类`
- hook 是把能提供的都提供了, 作为基类使用, 但是`SyncHook`在实例化的时候, 会调用 hook 类的构造器, 这样就具备了一身的功能, 但是有一些功能需要砍一刀或者重写, 这样才是自己的实例, 并且完成实例化
- 接下来就是`tap`方法

## tap 方法

```js
_tap(type, options, fn) {
	if (typeof options === "string") {
		options = {
			name: options.trim()
		};
	} else if (typeof options !== "object" || options === null) {
		throw new Error("Invalid tap options");
	}
	if (typeof options.name !== "string" || options.name === "") {
		throw new Error("Missing name for tap");
	}
	if (typeof options.context !== "undefined") {
		deprecateContext();
	}
	options = Object.assign({ type, fn }, options);
	options = this._runRegisterInterceptors(options);
	this._insert(options);
}

_runRegisterInterceptors(options) {
	for (const interceptor of this.interceptors) {
		if (interceptor.register) {
			const newOptions = interceptor.register(options);
			if (newOptions !== undefined) {
				options = newOptions;
			}
		}
	}
	return options;
}

tap(options, fn) {
	this._tap("sync", options, fn);
}
```

如上面的tap方法, 又一次回到hook中, 这也就是上面说的, hook才是核心, 基本上啥都已经提前实现好了, 剩下的Hook都是在这个基类上做了一点扩展

这里的`options`就是我们传入的一个`tap`的名字, 而`fn`就是回调函数

进入`_tap`后首先需要判断options是不是一个string, 如果是, 则去掉空格, 将options变成一个对象, 添加一个成员name, 就是捞options的值去除前后空格

如果不是字符串, 也不是一个object, 或者是null, 那么将直接报错

接下来的判断很明显是不成立的, 属于便捷条件鉴定, 也就是options本身就是一个对象, 但是他的name属性又不是一个字符串, 或者说name属性还是一个空字符串的情况下, 都会抛错, 说明这一波tap, 存储的fn, 是无名氏

接下来是后续用的东西, 暂时不用

接下来是合并对象, 扩展options, 将type和fn加入其中

接下来执行`_runRegisterInterceptors`, 主要是注册一个拦截器, 因为hook在执行的过程中, 是可以拦截的, 但是现在还用不上

### `_insert`方法

```js
_insert(item) {
	this._resetCompilation();
	let before;
	if (typeof item.before === "string") {
		before = new Set([item.before]);
	} else if (Array.isArray(item.before)) {
		before = new Set(item.before);
	}
	let stage = 0;
	if (typeof item.stage === "number") {
		stage = item.stage;
	}
	let i = this.taps.length;
	while (i > 0) {
		i--;
		const x = this.taps[i];
		this.taps[i + 1] = x;
		const xStage = x.stage || 0;
		if (before) {
			if (before.has(x.name)) {
				before.delete(x.name);
				continue;
			}
			if (before.size > 0) {
				continue;
			}
		}
		if (xStage > stage) {
			continue;
		}
		i++;
		break;
	}
	this.taps[i] = item;
}

_resetCompilation() {
	this.call = this._call;
	this.callAsync = this._callAsync;
	this.promise = this._promise;
}
```

首先执行`_resetCompilation`, 就是做一些初始化

定义了一个变量叫`before`, 后面有一些判断, 暂时用不上

一直到`	let i = this.taps.length;`这里, 然后i是0, 因为taps还是一个空数组, 接下来就会执行`this.taps[0] = item`, 将item赋值给taps的一号位

item就是外面传入的options

这样, tap的第一个过程到此结束, 主要就是将options中的第一个值传给tap的第一个值, 到此为止, tap调用完成, 继续走, 就到了第二个tap

## 小结

有几个核心的类, 一个是SyncHook, 在一个就是Hook, 然后是HookCodeFactory

然后再Hook中有很多东西, 而SyncHook有点类似于继承了Hook, 但是SyncHook又有一些自己的东西, 比如tapAsync以及tapPromise, 这里不能用, 因此需要重写

而实例化完成后, 身上就多了两个比较重要的属性, 一个是`_x`, 还有一个是`taps`

`_x`之前说过, 就是转换的`taps`, 将其中的回调函数取出来单独组成一个数组

`taps`这里说了, 就是保留了一个对象数组, 每一个数组成员的对象中, 都包含了tap执行后传入的名称, 回调函数以及钩子的类型, 然后通过`_insert`加入到`taps`中

后续在有tap, 就会循环调用



