---
title: addEntry 流程分析
date: 2021-08-22
tags:
    - webpack
    - webpackSource
categories:
    - webpack源码解析
---

# addEntry 流程分析

```js
// compiler.run
this.hooks.make.callAsync(compilation, err => {
	logger.timeEnd("make hook");
	if (err) return callback(err);

	logger.time("finish make hook");
	this.hooks.finishMake.callAsync(compilation, err => {
		logger.timeEnd("finish make hook");
		if (err) return callback(err);

		process.nextTick(() => {
			logger.time("finish compilation");
			compilation.finish(err => {
				logger.timeEnd("finish compilation");
				if (err) return callback(err);

				logger.time("seal compilation");
				compilation.seal(err => {
					logger.timeEnd("seal compilation");
					if (err) return callback(err);

					logger.time("afterCompile hook");
					this.hooks.afterCompile.callAsync(compilation, err => {
						logger.timeEnd("afterCompile hook");
						if (err) return callback(err);

						return callback(null, compilation);
					});
				});
			});
		});
	});
});

// EntryPlugin.js
const { entry, options, context } = this;
const dep = EntryPlugin.createDependency(entry, options);

compiler.hooks.make.tapAsync("EntryPlugin", (compilation, callback) => {
	compilation.addEntry(context, dep, options, err => {
		callback(err);
	});
});
```

1. 接着前面的总结, make 走姿在触发的时候, 接收到了 compilation 实例对象
2. 整个程序就是在一个逻辑中让模块从入口进去, 经过webpack处理完成后从出口流出的一个过程, 所以数据和逻辑一定要明白, 代码实现反复看就可以了
3. 从 compilation 中解构出了三个值：
  + entry: 当前需要被打包的模块的相对路径
  + options: 之前通过一个函数组装的options, 入口模块除了name, 都是undefined
  + context: 当前项目的根路径
4. dep 是对当前入口模块中的依赖关系进行处理
5. 接着才是make钩子回调, 调用 `addEntry` 方法

## addEntry 方法

```js
addEntry(context, entry, optionsOrName, callback) {
  // 这里主要是确定 optionsOrName是不是一个对象, 一般我们这里传入的是一个对象, 组装的时候除了name, 都是undefined
  // 如果不是一个对象, 则转成一个对象, 然后将该值赋值给 name 属性
  // 主要是为了统一数据结构
  // 这里的 entry 是 上述的dep(它其实就是入口依赖), 作用是处理当前入口模块中的依赖关系, 内部包含有入口模块的相对路径
	// TODO webpack 6 remove, 这个是说webpack6将移除这个options
	const options =
		typeof optionsOrName === "object"
			? optionsOrName
			: { name: optionsOrName };

	this._addEntryItem(context, entry, "dependencies", options, callback);
}

_addEntryItem(context, entry, target, options, callback) {
  // 将name结构出来
	const { name } = options;
  // 对于入口模块, 初次走到这里的时候, name是有东西的, 但是 this.entries.get(name)取不到任何东西, 因此这个entryData是一个undefined
	let entryData =
		name !== undefined ? this.entries.get(name) : this.globalEntry;
	if (entryData === undefined) {
    // 因此会直接进入这里
		entryData = {
			dependencies: [], // 内部会加入入口依赖
			includeDependencies: [], // 最终是一个空数组
			options: { // 最终结果和外面的options一样, 除了name, 都是空数组
				name: undefined,
				...options
			}
		};
		entryData[target].push(entry);
    // 为 entries 这个map数据结构, 添加一个键名为入口模块id, 键值为 entryData的值
		this.entries.set(name, entryData);
	} else {
		entryData[target].push(entry);
		for (const key of Object.keys(options)) {
			if (options[key] === undefined) continue;
			if (entryData.options[key] === options[key]) continue;
			if (
				Array.isArray(entryData.options[key]) &&
				Array.isArray(options[key]) &&
				arrayEquals(entryData.options[key], options[key])
			) {
				continue;
			}
			if (entryData.options[key] === undefined) {
				entryData.options[key] = options[key];
			} else {
				return callback(
					new WebpackError(
						`Conflicting entry option ${key} = ${entryData.options[key]} vs ${options[key]}`
					)
				);
			}
		}
	}

  // 触发 addEntry钩子, 传入 entry 和 options
  // 注意, 这里的 addEntry 钩子是 compilation 的钩子
	this.hooks.addEntry.call(entry, options);

  // 紧接着执行 addModuleTree 方法, 作用就是生成一个模块树
	this.addModuleTree(
		{
			context,
			dependency: entry,
			contextInfo: entryData.options.layer
				? { issuerLayer: entryData.options.layer }
				: undefined
		},
		(err, module) => {
			if (err) {
				this.hooks.failedEntry.call(entry, options, err);
				return callback(err);
			}
			this.hooks.succeedEntry.call(entry, options, module);
			return callback(null, module);
		}
	);
}

addModuleTree({ context, dependency, contextInfo }, callback) {
    // 接着就走到这里, context 是绝对路径, dependency 就是上面的dep(入口模块依赖), contextInfo是undefined
		if (
			typeof dependency !== "object" ||
			dependency === null ||
			!dependency.constructor
		) {
      // 这里不会进去, 直接过
			return callback(
				new WebpackError("Parameter 'dependency' must be a Dependency")
			);
		}
    // 这个 dependency, 就是外面的dep, 他是属于EntryDependency这个类的一个实例
    // 因此这里就得到了这个类(实例的constructor指向创建实例的类), 也就是所谓的 EntryPlugin 类
		const Dep = /** @type {DepConstructor} */ (dependency.constructor);
    // 这个就是所谓的模块工厂
    // 前面说过, 如果要加载一个模块, 首先要先去创建一个模块, 然后再生成的模块内部, 再去定义需要加载的模块就可以了
    // 这里就会得到一个工厂模块
    // 这个 dependencyFactories , 在 EntryPlugin 那个位置, 定义了一个compilation钩子, 这个钩子触发的时候, 回调函数里面
    // 就会给 compilation.dependencyFactories, 设置一个键名为 `EntryDependency类`, 键值就是前面说的 `normalModuleFactory`
    // 所以说这个 moduleFactory 就是前面的 normalModuleFactory 
    // 于是乎后续就是要利用这个 normalModuleFactory 来创建一个普通的模块对象
		const moduleFactory = this.dependencyFactories.get(Dep);
		if (!moduleFactory) {
			return callback(
				new WebpackError(
					`No dependency factory available for this dependency type: ${dependency.constructor.name}`
				)
			);
		}

		this.handleModuleCreation(
			{
				factory: moduleFactory,
				dependencies: [dependency],
				originModule: null,
				contextInfo,
				context
			},
			err => {
				if (err && this.bail) {
					callback(err);
					this.buildQueue.stop();
					this.rebuildQueue.stop();
					this.processDependenciesQueue.stop();
					this.factorizeQueue.stop();
				} else {
					callback();
				}
			}
		);
	}

  handleModuleCreation(
		{
			factory,
			dependencies,
			originModule,
			contextInfo,
			context,
			recursive = true,
			connectOrigin = recursive
		},
		callback
	) {
    // 生成了一个模块图, 具体做什么用还不知道
		const moduleGraph = this.moduleGraph;
    
    // this.profile是false, 因此这个值是undefined
		const currentProfile = this.profile ? new ModuleProfile() : undefined;

    // 紧接着会直接进入这里面
		this.factorizeModule(
			{
				currentProfile,
				factory,
				dependencies,
				originModule,
				contextInfo,
				context
			},
			(err, newModule) => {
				if (err) {
					if (dependencies.every(d => d.optional)) {
						this.warnings.push(err);
						return callback();
					} else {
						this.errors.push(err);
						return callback(err);
					}
				}

				if (!newModule) {
					return callback();
				}

				if (currentProfile !== undefined) {
					moduleGraph.setProfile(newModule, currentProfile);
				}

				this.addModule(newModule, (err, module) => {
					if (err) {
						if (!err.module) {
							err.module = module;
						}
						this.errors.push(err);

						return callback(err);
					}

					for (let i = 0; i < dependencies.length; i++) {
						const dependency = dependencies[i];
						moduleGraph.setResolvedModule(
							connectOrigin ? originModule : null,
							dependency,
							module
						);
					}

					moduleGraph.setIssuerIfUnset(
						module,
						originModule !== undefined ? originModule : null
					);
					if (module !== newModule) {
						if (currentProfile !== undefined) {
							const otherProfile = moduleGraph.getProfile(module);
							if (otherProfile !== undefined) {
								currentProfile.mergeInto(otherProfile);
							} else {
								moduleGraph.setProfile(module, currentProfile);
							}
						}
					}

					// Check for cycles when build is trigger inside another build
					let creatingModuleDuringBuildSet = undefined;
					if (!recursive && this.buildQueue.isProcessing(originModule)) {
						// Track build dependency
						creatingModuleDuringBuildSet =
							this.creatingModuleDuringBuild.get(originModule);
						if (creatingModuleDuringBuildSet === undefined) {
							creatingModuleDuringBuildSet = new Set();
							this.creatingModuleDuringBuild.set(
								originModule,
								creatingModuleDuringBuildSet
							);
						}
						creatingModuleDuringBuildSet.add(originModule);

						// When building is blocked by another module
						// search for a cycle, cancel the cycle by throwing
						// an error (otherwise this would deadlock)
						const blockReasons = this.creatingModuleDuringBuild.get(module);
						if (blockReasons !== undefined) {
							const set = new Set(blockReasons);
							for (const item of set) {
								const blockReasons = this.creatingModuleDuringBuild.get(item);
								if (blockReasons !== undefined) {
									for (const m of blockReasons) {
										if (m === module) {
											return callback(new BuildCycleError(module));
										}
										set.add(m);
									}
								}
							}
						}
					}

					this.buildModule(module, err => {
						if (creatingModuleDuringBuildSet !== undefined) {
							creatingModuleDuringBuildSet.delete(module);
						}
						if (err) {
							if (!err.module) {
								err.module = module;
							}
							this.errors.push(err);

							return callback(err);
						}

						if (!recursive) {
							this.processModuleDependenciesNonRecursive(module);
							callback(null, module);
							return;
						}

						// This avoids deadlocks for circular dependencies
						if (this.processDependenciesQueue.isProcessing(module)) {
							return callback();
						}

						this.processModuleDependencies(module, err => {
							if (err) {
								return callback(err);
							}
							callback(null, module);
						});
					});
				});
			}
		);
	}

  factorizeModule(options, callback) {
		this.factorizeQueue.add(options, callback);
	}

  // AsyncQueue.js 的 add方法
  add(item, callback) {
		if (this._stopped) return callback(new WebpackError("Queue was stopped"));
		this.hooks.beforeAdd.callAsync(item, err => {
			if (err) {
				callback(
					makeWebpackError(err, `AsyncQueue(${this._name}).hooks.beforeAdd`)
				);
				return;
			}
			const key = this._getKey(item);
			const entry = this._entries.get(key);
			if (entry !== undefined) {
				if (entry.state === DONE_STATE) {
					if (inHandleResult++ > 3) {
						process.nextTick(() => callback(entry.error, entry.result));
					} else {
						callback(entry.error, entry.result);
					}
					inHandleResult--;
				} else if (entry.callbacks === undefined) {
					entry.callbacks = [callback];
				} else {
					entry.callbacks.push(callback);
				}
				return;
			}
			const newEntry = new AsyncQueueEntry(item, callback);
			if (this._stopped) {
				this.hooks.added.call(item);
				this._root._activeTasks++;
				process.nextTick(() =>
					this._handleResult(newEntry, new WebpackError("Queue was stopped"))
				);
			} else {
				this._entries.set(key, newEntry);
				this._queued.enqueue(newEntry);
				const root = this._root;
				root._needProcessing = true;
				if (root._willEnsureProcessing === false) {
					root._willEnsureProcessing = true;
					setImmediate(root._ensureProcessing);
				}
				this.hooks.added.call(item);
			}
		});
	}
```

### 逻辑梳理

1. 统一`options`的数据结构, 因为这里很可能传入的`optionsOrName`是一个 String, 也就是和4.x一样是一个name(也不排除是compilation这个类先更新了, 而当时的compiler还没有更新, 因此这里相当于是做一个兼容处理)
2. 接着开始调用 `_addEntryItem`方法
3. 在 `_addEntryItem`方法内部, 主要是定义了一个 `entryData`, 同时给 compilation.entries设置了一个键名为入口模块id, 键值为 entryData的 map成员
4. 然后触发了 `addEntry` 钩子, 这个钩子是 compilation 的钩子, 而不是compiler的钩子, 并且继续执行 `addModuleTree` 方法
5. 这个 `addModuleTree`方法, 根据他的名字我们知道, 它主要是要生成一个模块树, 也就是说要真正的开始生成所需要的模块了
   + 5-1 `addModuleTree`方法内部主要做的事情就是拿到了前面在 EntryPlugin 中定义的 `normalModuleFactory`, 这个普通模块工厂, 就是用于生成模块的东西
   + 5-2 执行 `handleModuleCreation`
6. `handleModuleCreation`


