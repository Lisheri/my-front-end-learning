---
title: 模块热更新
date: 2021-05-14
tags:
 - 模块化
 - webpack
categories: 
 - 前端工程化
---

# 模块热更新

## 自动刷新问题

在此之前, 我们简单了解了webpack dev server简单的用法和基础的特性, 主要就是

> 提供对开发者友好的开发服务器

他可以让我们专注于编码, 因为他可以监视到代码的变化, 自动进行打包, 并且同步刷新到浏览器中

但实际上使用这些特性进行开发的时候, 会发现还是会有一些不舒服的地方

比如有一个编写文本的样例, 我有一些测试文本, 但是当我修改完代码后, 就会发现, 我添加的测试文本, 在他重新同步后, 就消失了。这样就不得不再来一把

久而久之, 就会觉得自动刷新并非那么好用

但是也有一些小办法, 比如在代码中先写死编辑器的内容, 这样即便刷新也不会丢失

又或者说先保存起来, 刷新了再取回来

但是这些都不是根治, 而是以动治动

+ 这个问题的核心在于: `自动刷新导致页面状态丢失`

更好地办法在于页面不刷新的前提下, 模块也可以及时更新

## HMR模块简介

`HMR`模块也就是我们常说的热更新模块(模块热替换), 全称是`Hot Module Replacement`

经常会听到一个叫做模块`热拔插`的名词, 在一个正在运行的机器上随时插拔设备, 并且极其不会受到设备拔插影响, 热替换, 就和这个是一个道理, 就是及时替换, 又不影响主要逻辑运行

要求就是在应用运行过程中实时替换某个模块, 应用运行状态不会受到影响

上面的应用整体刷新, 导致状态丢失, 就不属于热替换

> 热替换: 只将修改的模块实时替换到应用中
> 
> HMR是Webpack中最强大的功能之一, 同时也是最受欢迎的特性
> 
>极大程度的提高了开发者的工作效率

## 开启HMR

对于热更新这种强大的功能而言, 他的使用并不算特别的复杂

`HMR`已经集成在了webpack-dev-server中, 不需要单独安装模块

方式:

+ 可以在运行webpack-dev-server时, 通过`--hot`开启这个特性
+ 可以通过配置文件, 并且配置插件`HotModuleReplacementPlugin`开启, 如下所示
    ```javaScript
        const webpack = require('webpack');
        module.exports = {
            ...
            devServer: {
                hot: true, // 除此之外, 还需要载入一个插件, 这个插件是webpack一个内置的模块, 叫做HotModuleReplacementPlugin
            },
            plugins: [
                ...
                new webpack.HotModuleReplacementPlugin()
            ]
        }
    ```

## 疑问

+ 这种方式会发现, 样式文件已经有热更新了, 但是js文件, 似乎还有问题
+ 这主要是因为HMR并不像其他特性一样, 可以`开箱即用`
+ HMR还需要做额外的操作, 才能正常工作
+ 他需要我们手动处理模块热替换逻辑

但是肯定有疑问

### Q1. 为什么样式文件的热更新开箱即用?

主要是因为, 样式文件在style-loader中自动处理了模块的热更新

### Q2. 凭什么样式可以自动处理?

原因就是, 样式模块更新后, 样式只需要覆盖原来的就可以了, 但是js模块没有任何规律, 导出成员和导出成员的使用, 各不相同, webpack不知道如何处理, 也就没有办法去给我们一个通用方案

### Q3. 我的项目没有手动处理, JS照样可以热替换?

主要还是框架的cli文件, 对框架依赖的js(.jsx, .vue, .tsx)等做了处理, 因为框架中的文件是有规律的

同时脚手架内部还集成了`HMR`方案

### 因此, 我们还需要手动处理JS模块更新后所要做的事情

## 使用HMR APIs

`HotModuleReplacementPlugin`为js代码提供了一套处理hmr的api, 我们需要在自己的代码中去使用这些api, 来处理当某一个模块更新后, 应该如何体现到我们的页面当中

比如我的例子中, main.js是入口, 一旦当这里的模块被更新后, 就需要重新处理

在这一套api当中, 为`module`对象提供了一个`hot`属性, 这个属性也是一个对象, 他就是hmr API的核心对象, 它提供了一个`accept`方法, 用于注册模块更新过后的处理函数

`accept`方法有两个参数, 第一个接收的是`依赖模块的路径`, 第二个是`依赖路径更新后的处理函数`

如下:

```javaScript
import createHeading from './heading.js';

import url from './favicons/github.png';

const heading = createHeading();

document.body.append(heading);

const img = new Image();

img.src = url;

document.body.append(img);


import './main.css';

module.hot.accept('./heading', () => {
    console.info("heading模块更新了, 需要手动处理热更新逻辑")
})
```

然后就会发现, 此时如果修改`heading`文件浏览器已经可以打印这个消息了, 并且也不会自动刷新了

也就是说如果我们没有对模块做这样的处理, 浏览器就会全部自动的刷新, 而不是热替换, 进而导致页面刷新

## 处理JS模块热替换

这个就是通过上述module.hot.accept()这个方式去编写对应的热替换规则, 这个不可通用

这也是为什么webpack不可能给出一个通用的替换方案

## 图片模块热替换

相比于js模块的热替换, 图片模块会简单很多

```javaScript
module.hot.accept('./favicons/github.png', () => {
    img.src = url; // 这里可以直接拿到最新的url, 做替换即可
})
```

其实看起来会多很多额外的代码, 但个人感觉还是利大于弊, 就像是写单元测试一样, 对于一个长期开发的项目, 这点额外的工作并不算什么, 并且可以为自己的项目, 提供通用的替换方案

当然, 用框架的话很简单, cli就提供了HMR方案

## HMR注意事项

1. 处理HMR的代码报错会导致自动刷新(有错误会不容易发现, 因为错误信息已经刷新被清除了)
   - 针对这个问题, 使用`hotOnly: true` 替换 `hot: true`
2. 没启用HMR的情况下, HMR API报错
   - 原因就是module.hot是`HotModuleReplacementPlugin`提供的 
3. 处理热替换的代码, 在生产上已经被移除了, 不会对生成产生任何影响(只会留下一个空判断, 并且压缩代码的时候这种无用判断会被移除)


