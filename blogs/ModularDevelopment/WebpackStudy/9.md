---
title: 优化生产环境
date: 2021-05-14
tags:
 - 模块化
 - webpack
categories: 
 - 前端工程化
---

# 优化生产环境

前面所有的开发环境的体验提升, 都会导致生产包变得越来越臃肿

这是因为, webpack为了实现这些特性, 会自动往输出结果中, 添加额外代码, 比如`Source Map`和`HMR`

但是这些额外的代码, 对于生产环境来说是冗余的

生产环境和开发环境有很大的差异, 生产注重运行效率(需要更少量更轻量的代码)

但是开发环境我们更注重方便, 一切为了提高开发效率

针对这个问题, webpack4.x提出了`模式(mode)`, `production`这个选项就已经做了大量的处理

同时webpack也建议为不同的工作环境创建不同的配置, 以便于让打包结果适用于不同环境

## 不同环境下的配置

先尝试为不同的工作环境创建不同的配置

方式有两种:

1. 配置文件根据环境不同导出不同的配置(process.env可以判断环境)
2. 一个环境对应一个配置文件(确保每个环境有一个对应的文件)

### 方式一. 配置文件根据环境不同导出不同的配置

webpack配置文件, 支持导出一个函数, 在函数中, 返回配置对象, 接收两个参数, 一个是`env`, 一个是`argv`

`env`是通过cli传递的运行环境名参数

`argv`是运行cli过程中所传入的所有参数

运行的时候使用`yarn webpack --env production`, 这就相当于在给webpack传递了一个env的参数, 就是production

此时接收到的`env`就是`{ WEBPACK_BUNDLE: true, WEBPACK_BUILD: true, production: true }` 

如果是development就是 `{ WEBPACK_BUNDLE: true, WEBPACK_BUILD: true, development: true }` 

如下所示:

```javaScript
module.exports = (env, argv) => {
    console.info(env)
    const config = {
        // 开发模式变量
        entry: './src/main.js', // 入口文件, 如果是一个相对路径, 前面的./是不能省略的
        output: { // output设置输出文件的配置, 该属性是一个对象
            filename: 'bundle.js', // 设置输出文件名称
            path: path.join(__dirname, 'dist'), // path执行文件输出所在的目录, 他必须使用绝对路径, 默认就是dist
            // publicPath: '/'
        },
        mode: 'none',
        devtool: 'eval',
        module: { // 使用loader需要添加具体的配置, 就是在webpack.config.js中添加一个module, 下面配置rules数组
            // rules就是针对其他资源的加载规则配置, 每一个规则对象都有两个属性：
            // 一个test属性, 是正则表达式, 用于匹配打包过程中所遇到的文件路径
            // 一个use属性, 用于表示使用的loader
            rules: [
                {
                    test: /.js$/,
                    use: {
                        loader: "babel-loader",
                        options: {
                            presets: ['@babel/preset-env']
                        },
                    },
                    exclude: path.join(__dirname, 'node_modules')
                },
                {
                    test: /.css$/,// 表示匹配所有的.css结尾的文件, 也就是匹配所有的css文件
                    use: [
                        // 改成数组后, 配置多个loader, 执行是从后往前执行, 就像一个栈一样, 先进后出, 最先进去的最后执行
                        'style-loader', 'css-loader'
                    ] // cssloader的作用就是将css文件转换成一个js模块, 具体实现就是将css代码转换成字符串push到了一个数组中
                    // 但是单纯向上面这样只使用一个css-loader就会发现没有任何代码引用这一串字符串
                    // 因此这里还需要一个style-loader, 就是将css的字符串通过style标签放到页面上
                    // 通过设置两个loader就会发现 __webpack_modules__下面多了两个模块, 主要代表的就是css-loader和style-loader模块
                    // css-loader生成的css字符串, 就通过 insertStyleElement函数 创建一个style标签, 挂载到页面中
                },
                {
                    test: /.(jpg|png|gif|bmp|jpeg)$/,
                    use: {
                        loader: 'url-loader',
                        // 其实所有的loader都可以通过这种方式去配置
                        options: {
                            limit: 10 * 1024, // 10kb大小限制, 这样之后大于10kb的依然会使用file-loader
                            // 这种方式是默认使用file-loader, 因此一定不要忘了安装file-loader
                        }
                    }
                },
                {
                    test: /.html$/,
                    use: {
                        loader: 'html-loader',
                        options: {
                            // attributes: ["img:src", "a:href"], // 目前已弃用这种方式
                            sources: {
                                list: [
                                    {
                                        tag: 'img', // 标签名
                                        attribute: 'src', // 挂载标签上的属性名
                                        type: 'src', // 属性名对应地原类型
                                    },
                                ]
                            },
                            minimize: process.env === 'production' ? true : false,
                            esModule: true
                        }
                    },
                    exclude: path.join(__dirname, 'index.html')
                }
            ]
        },
        plugins: [ // 配置插件的数组
            new HtmlWebpackPlugin({
                title: 'webpack学习',
                filename: 'index.html',
                template: 'index.html',
                inject: 'body',
                // meta: {
                //     viewport: 'width=device-width'
                // }
            }),
            // new CopyWebpackPlugin({
            //     patterns: [
            //         { from: "src/favicons", to: "dest" },
            //     ],
            // }),
            new myPlugin(),
            new webpack.HotModuleReplacementPlugin()
        ],
        devServer: {
            http2: true,
            hot: true,
            // open: true,
            // https: true,
            contentBase: [
                path.join(__dirname, 'src/favicons')
            ], // 可以是字符串, 也可以是数组
            proxy: {
                '/api': {
                    // 也就是说请求 localhost:3000/api/users -> https://api.github.com/api/users
                    target: 'https://api.github.com',
                    // 但是在https://api.github.com的接口中并没有/api, 因此需要添加一层代理路径的重写
                    pathRewrite: {
                        '^/api': "", // 这个属性最终会生成一个正则去匹配上面的路径
                    },
                    // ws: true,
                    // timeout: 9999999999,
                    // 不能使用localhost:3000作为请求 github 的主机名
                    // 主机名由于服务端判断请求应该走哪一个网站, 设置changeOrigin为true, 就会将代理请求作为实际的主机名去请求
                    changeOrigin: true,
                }
            }
        }
    }
    if (env.production) {
        // env.production 已经不再是以前那种直接就是值了, 而是确定下面的production是否为true
        console.info("123")
        config.mode = 'production';
        config.devtool = false;
        config.plugins = [
            ...config.plugins,
            // 这里添加clean-webpack-plugin和copy-webpack-plugin, 这两个就是之前说的开发阶段可以省略的插件
            new CleanWebpackPlugin(),
            new CopyWebpackPlugin({
                patterns: [
                    { from: "src/favicons", to: "dest" },
                ],
            })
        ]
    }
    return config;
}
```

当然, 也可以在全局做判断, 根据不同的环境, 导出不同的配置

### 方式二. 不同环境对应不同的配置文件

方式一只适合中小型项目, 如果一旦项目变得复杂, 那么配置文件也会一起变得复杂起来

一般我们都有三个webpack配置文件, 其中有两个用于适配不同的环境, 另一个是公共配置, 因为开发和生产, 并不是所有的都不同

生产和开发需要合并common的配置, 这里使用`webpack-merge`这个模块提供的`merge`函数, 毕竟使用原生方法, 对于引用类型的合并不好操作(当然也可以自己写一个, 也可以使用lodash.merge函数)

并且在使用的时候要使用`--config webpack.prod.js`去指定对应的配置文件

```javaScript
// common
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin'); // 载入HtmlWebpackPlugin, 他不需要解构, 默认导出就是
const webpack = require('webpack');

class myPlugin {
    // 定义一个类, 然后定义一个apply方法
    apply(compiler) {
        // apply方法会在webpack启用时, 自动被调用
        // 接收一个compiler对象参数, 这个对象就是webpack工作过程中的核心对象, 包含了此次构建的所有配置信息, 也是通过这个对象去注册钩子函数
        // 这里编写一个插件用于去除打包过程后bundle.js下所有的注释, 因此, 这个过程应该是在bundle.js出现后实施
        // emit在 输出 asset 到 output 目录之前执行(就是即将往输出目录输出文件)
        // ! 通过compiler.hooks.emit去访问到这个钩子, 通过tap方法去注册函数
        // ! tap方法接收两个参数, 第一个是插件名称, 第二个就是挂载到这个钩子上的函数了
        compiler.hooks.emit.tap("myPlugin", compilation => {
            // * compilation这个对象可以理解成此次打包过程中的上下文, 打包结果都会放到这个对象中
            // assets是即将写入目录中的资源文件信息, 是一个对象, 键名是文件的名称
            for (const name in compilation.assets) {
                // 通过source方法可以拿到对应地内容
                // 需求是做一个去除bundle.js注释的插件, 因此要判断文件名
                if (name.match(/.js$/)) {
                    // console.info(compilation.assets[name].source())
                    // 然后进行处理
                    const contents = compilation.assets[name].source();
                    const withoutComments = contents.replace(/\/\*\*+\*\//g, "");
                    // 处理完成后, 需要去替换compilation.assets下的对应地内容
                    compilation.assets[name] = {
                        source: () => withoutComments, // 依然使用一个source方法去暴露
                        size: () => withoutComments.length, // 还需要一个size方法, 去返回一个内容的大小, 这个是webpack要求的所必须的方法
                    }
                }
            }
        })
    }
}

module.exports = {
    // 开发模式变量
    entry: './src/main.js', // 入口文件, 如果是一个相对路径, 前面的./是不能省略的
    output: { // output设置输出文件的配置, 该属性是一个对象
        filename: 'bundle.js', // 设置输出文件名称
        path: path.join(__dirname, 'dist'), // path执行文件输出所在的目录, 他必须使用绝对路径, 默认就是dist
        // publicPath: '/'
    },
    mode: 'none',
    devtool: 'eval',
    module: {
        rules: [
            {
                test: /.js$/,
                use: {
                    loader: "babel-loader",
                    options: {
                        presets: ['@babel/preset-env']
                    },
                },
                exclude: path.join(__dirname, 'node_modules')
            },
            {
                test: /.css$/,
                use: [
                    'style-loader', 'css-loader'
                ]
            },
            {
                test: /.(jpg|png|gif|bmp|jpeg)$/,
                use: {
                    loader: 'url-loader',
                    options: {
                        limit: 10 * 1024,
                    }
                }
            },
            {
                test: /.html$/,
                use: {
                    loader: 'html-loader',
                    options: {
                        // attributes: ["img:src", "a:href"], // 目前已弃用这种方式
                        sources: {
                            list: [
                                {
                                    tag: 'img', // 标签名
                                    attribute: 'src', // 挂载标签上的属性名
                                    type: 'src', // 属性名对应地原类型
                                },
                            ]
                        },
                        minimize: process.env === 'production' ? true : false,
                        esModule: true
                    }
                },
                exclude: path.join(__dirname, 'index.html')
            }
        ]
    },
    plugins: [ // 配置插件的数组
        new HtmlWebpackPlugin({
            title: 'webpack学习',
            filename: 'index.html',
            template: 'index.html',
            inject: 'body',
        }),
        new myPlugin(),
        new webpack.HotModuleReplacementPlugin()
    ],
    devServer: {
        http2: true,
        hot: true,
        // open: true,
        // https: true,
        contentBase: [
            path.join(__dirname, 'src/favicons')
        ], // 可以是字符串, 也可以是数组
        proxy: {
            '/api': {
                // 也就是说请求 localhost:3000/api/users -> https://api.github.com/api/users
                target: 'https://api.github.com',
                // 但是在https://api.github.com的接口中并没有/api, 因此需要添加一层代理路径的重写
                pathRewrite: {
                    '^/api': "", // 这个属性最终会生成一个正则去匹配上面的路径
                },
                // ws: true,
                // timeout: 9999999999,
                // 不能使用localhost:3000作为请求 github 的主机名
                // 主机名由于服务端判断请求应该走哪一个网站, 设置changeOrigin为true, 就会将代理请求作为实际的主机名去请求
                changeOrigin: true,
            }
        }
    }
}

// prod
const common = require('./webpack.common');
const CopyWebpackPlugin = require('copy-webpack-plugin');
const { CleanWebpackPlugin } = require("clean-webpack-plugin"); // 这个模块解构出来一个CleanWebpackPlugin, 就是用于清除dist目录的插件
const { merge } = require('webpack-merge');

// 使用Object.assign会后项完全覆盖前项相同键名的属性, 但是对于引用类型, 我们只希望做添加, 而不是完全覆盖
// 所以Object.assign并不合适, 可以使用lodash.merge, 不过社区中提供了专用的webpackMerge这个库
module.exports = merge(common, {
    mode: "production",
    plugins: [
        new CleanWebpackPlugin(),
        new CopyWebpackPlugin({
            patterns: [
                { from: "src/favicons", to: "dest" },
            ],
        }),
    ],
    devtool: false
})
```

## DefinePlugin

webpack4新增了很多开箱即用优化配置, 用起来很爽, 但是要了解原理, 会让我们无从下手, 因此如果我们要深入了解, 还是要单独研究一下背后的作用

第一个就是这个插件`DefinePlugin`

为代码注入全局成员, 这个东西默认会启用起来, 并且注入了一个叫做`process.env.NODE_ENV`的变量, 很多模块都是通用这个成员去判断运行环境, 决定是否执行打印日志等操作

这个插件的构造函数接收一个对象, 对象的每一个键值, 都是往process.env中注入的东西

使用如下:

```javaScript
new webpack.DefinePlugin({
   // 注入api服务地址
   API_BASE_URL: 'https://api.example.com'
)
```

找到打包结果, 可以发现他其实就是把注入成员的值, 直接替换到了代码中

```javaScript
// main.js
console.info(API_BASE_URL);

// bundle.js
console.info(https://api.example.com);
```

会发现有点问题, 因为没有引号了, 因为他要求的实际上是传递一段js的代码片段, 并不是用于传值的

需要修改为 `API_BASE_URL: '"https://api.example.com"'`

当然, 如果要传值, 最好的方式还是使用`JSON.stringify()`处理一波

> 结论: 有了这个插件, 我们可以注入任何我们想要的一些特殊字段

## Tree-shaking

字面意思就是摇树，伴随这一个摇树的动作, 树上的枯树枝等就会落下来

这里的tree-shaking就是`摇掉`代码中未引用的部分

这部分代码有一个专业术语叫做`未引用代码(dead-code)`

他可以自动检测出未引用的代码, 并移除他们

这个功能会在生产环境下自动开启

### 使用tree-shaking

需要注意的是, tree shaking不是指某个配置选项, 他是一组功能搭配使用过后的效果, 这个功能会在production模式下自动开启

如果在其他模式下手动开启tree-shaking

可以添加一个`optimization`属性， 这个属性就是集中配置webpack中优化功能的属性

我们只需要配置两个成员, `usedExports`用于标记未使用的成员, `minimize`压缩代码(去除未使用的成员)

```javaScript
optimization: {
    usedExports: true,
    minimize: true
}
```

可以将`usedExports`比作标记枯树枝, `minimize`负责「摇掉」他们

