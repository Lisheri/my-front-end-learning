(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{517:function(v,_,t){v.exports=t.p+"assets/img/tonggou.691a749f.png"},518:function(v,_,t){v.exports=t.p+"assets/img/nuxt1.50b8c9c3.png"},623:function(v,_,t){"use strict";t.r(_);var a=t(5),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,a=v._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[a("h1",{attrs:{id:"现代化的服务端渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#现代化的服务端渲染"}},[v._v("#")]),v._v(" 现代化的服务端渲染")]),v._v(" "),a("p",[v._v("上一节说了CSR渲染的显著问题, 也就是"),a("code",[v._v("首屏渲染慢")]),v._v("和"),a("code",[v._v("不利于SEO")])]),v._v(" "),a("p",[v._v("其实解决他们的方式非常简单, 就是结合服务端渲染, 来解决这两个问题")]),v._v(" "),a("h2",{attrs:{id:"服务端渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务端渲染"}},[v._v("#")]),v._v(" 服务端渲染")]),v._v(" "),a("p",[v._v("从本质上来说, 肯定是要使用服务端渲染, 但是又不是传统意义上的SSR, 和之前说的传统的SSR是不同的")]),v._v(" "),a("p",[v._v("现代化的服务端渲染, 其实应该叫做 -> "),a("code",[v._v("同构渲染")])]),v._v(" "),a("h2",{attrs:{id:"同构渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同构渲染"}},[v._v("#")]),v._v(" 同构渲染")]),v._v(" "),a("p",[v._v("其实就是后端渲染 + 前端渲染")]),v._v(" "),a("p",[v._v("在这种模式下, 既有后端渲染的优点, 又有前端渲染的优点")]),v._v(" "),a("ul",[a("li",[v._v("基于React、Vue等框架, 客户端渲染和服务端渲染的结合\n"),a("ul",[a("li",[v._v("在服务器端执行一次框架代码, 用于实现服务端渲染(首屏直出)")]),v._v(" "),a("li",[v._v("在客户端在执行一次框架代码, 用于接管页面交互, 从而将其生成一个SPA应用(之后所有的交互, 都是CSR)")])])]),v._v(" "),a("li",[v._v("核心解决SEO和首屏渲染慢的问题")]),v._v(" "),a("li",[v._v("拥有传统服务端渲染的优点, 也有客户端渲染的优点")])]),v._v(" "),a("h3",{attrs:{id:"核心流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#核心流程"}},[v._v("#")]),v._v(" 核心流程")]),v._v(" "),a("p",[a("img",{attrs:{src:t(517),alt:"同构渲染"}})]),v._v(" "),a("ol",[a("li",[v._v("首先在客户端请求网页地址")]),v._v(" "),a("li",[v._v("服务端收到请求后, 查询页面所需数据")]),v._v(" "),a("li",[v._v("拿到数据后, 渲染页面以及生成客户端SPA脚本")]),v._v(" "),a("li",[v._v("渲染完成后返回HTML(渲染好的页面内容 + 客户端SPA脚本)")]),v._v(" "),a("li",[v._v("客户端拿到内容后, 直接呈现服务端返回的HTML内容")]),v._v(" "),a("li",[v._v("为了保持SPA的优点, 所以需要通过页面中的脚本激活为SPA应用")]),v._v(" "),a("li",[v._v("之后所有的页面交互, 都变成了CSR")])]),v._v(" "),a("h3",{attrs:{id:"如何实现同构渲染"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何实现同构渲染"}},[v._v("#")]),v._v(" 如何实现同构渲染?")]),v._v(" "),a("ul",[a("li",[v._v("使用Vue、React等框架的官方解决方案\n"),a("ul",[a("li",[v._v("优点: 有助于理解原理")]),v._v(" "),a("li",[v._v("缺点: 需要搭建环境, 比较麻烦")])])]),v._v(" "),a("li",[v._v("使用第三方的解决方案\n"),a("ul",[a("li",[v._v("React生态的Next.js")]),v._v(" "),a("li",[v._v("Vue生态的Nuxt.js")]),v._v(" "),a("li",[v._v("...其他")])])])]),v._v(" "),a("h2",{attrs:{id:"同构渲染的问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同构渲染的问题"}},[v._v("#")]),v._v(" 同构渲染的问题")]),v._v(" "),a("ul",[a("li",[v._v("开发条件所限\n"),a("ul",[a("li",[v._v("浏览器特定的代码只能在某些生命周期钩子函数中使用")]),v._v(" "),a("li",[v._v("一些外部扩展库可能需要特殊处理才能在SSR应用中运行")]),v._v(" "),a("li",[v._v("不能再Server Render期间操作DOM")]),v._v(" "),a("li",[v._v("...")]),v._v(" "),a("li",[v._v("某些代码需要区分运行环境(基本都是这个问题, 因为nuxt既要运行到服务端, 也要运行到客户端)")])])]),v._v(" "),a("li",[v._v("设计构建设置和部署的更多要求\n"),a("ul",[a("li",[a("img",{attrs:{src:t(518),alt:"SSR"}})])])]),v._v(" "),a("li",[v._v("更多的服务器端负载\n"),a("ul",[a("li",[v._v("在Node中渲染完整的应用程序, 相比仅仅提供静态文件的服务器需要大量占用CPU资源")]),v._v(" "),a("li",[v._v("如果应用在高流量环境下使用, 需要准备相应的服务器负载")]),v._v(" "),a("li",[v._v("需要更多的服务端渲染优化工作处理")])])])]),v._v(" "),a("h2",{attrs:{id:"ssr使用建议"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ssr使用建议"}},[v._v("#")]),v._v(" SSR使用建议")]),v._v(" "),a("ul",[a("li",[v._v("首屏渲染速度是否真的重要?")]),v._v(" "),a("li",[v._v("是否真的需要SEO?")])])])}),[],!1,null,null,null);_.default=s.exports}}]);