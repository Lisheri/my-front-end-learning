(window.webpackJsonp=window.webpackJsonp||[]).push([[154],{739:function(e,t,s){"use strict";s.r(t);var a=s(5),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"reconciler"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reconciler"}},[e._v("#")]),e._v(" reconciler")]),e._v(" "),s("p",[e._v("reconciler是react核心逻辑所在的模块, 中文名叫协调器.")]),e._v(" "),s("p",[e._v("协调, 就是diff算法的意思")]),e._v(" "),s("h2",{attrs:{id:"意义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#意义"}},[e._v("#")]),e._v(" 意义")]),e._v(" "),s("p",[e._v("在前端框架之前, 都是使用的 jq进行开发, 这种工作模式叫做 "),s("code",[e._v("过程驱动")]),e._v(", 也就是开发者直接使用jq代理调用浏览器宿主环境的api, api执行完成后直接显示需要的UI")]),e._v(" "),s("p",[e._v("在框架出现以后, 我们转换了开发模式, 变成了 "),s("code",[e._v("状态驱动")])]),e._v(" "),s("p",[e._v("最后还是调用宿主环境API, 通过宿主环境API运行后显示对应的DOM.")]),e._v(" "),s("p",[e._v("但是这种调用并非开发者直接调用了, 而是改成开发者维系状态, 状态改变后, 通过核心模块根据不同的宿主环境, 调用不同的api, 去驱动视图显示最新的UI")]),e._v(" "),s("p",[e._v("对于 react, 他的核心模块就是 "),s("code",[e._v("reconciler")]),e._v(", 对于vue(3)来说, 核心模块是 "),s("code",[e._v("renderer")])]),e._v(" "),s("ol",[s("li",[e._v("消费jsx")]),e._v(" "),s("li",[e._v("开放通用API供不同的宿主环境使用")]),e._v(" "),s("li",[e._v("没有编译优化(Vue有编译优化)")])]),e._v(" "),s("h2",{attrs:{id:"核心模块消费jsx的过程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#核心模块消费jsx的过程"}},[e._v("#")]),e._v(" 核心模块消费jsx的过程")]),e._v(" "),s("h3",{attrs:{id:"核心模块操作的数据结构"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#核心模块操作的数据结构"}},[e._v("#")]),e._v(" 核心模块操作的数据结构")]),e._v(" "),s("p",[e._v("目前已知的数据结构是: "),s("code",[e._v("ReactElement")]),e._v(", 也就是jsx方法执行后获取的结果")]),e._v(" "),s("p",[e._v("但是 "),s("code",[e._v("ReactElement")]),e._v("是否可以作为核心模块消费数据结构?")]),e._v(" "),s("p",[e._v("答案是否定的, 存在几个问题")]),e._v(" "),s("ol",[s("li",[e._v("首先无法表达节点间的关系, 只能表达某一个节点内部的关系")]),e._v(" "),s("li",[e._v("字段有限, 不好扩展, 没有办法表达状态")])]),e._v(" "),s("p",[e._v("所以需要一种全新的数据结构, 要介于ReactElement与真实UI之间")]),e._v(" "),s("ul",[s("li",[e._v("可以表达节点间的关系")]),e._v(" "),s("li",[e._v("方便扩展, 不仅可以作为数据的存储单元, 也可以作为工作单元, 可以表达节点接下来将发生什么变化")])]),e._v(" "),s("p",[e._v("其实这个节点就是"),s("code",[e._v("FiberNode")]),e._v("(也就是React的"),s("code",[e._v("虚拟DOM")]),e._v("实现, Vue中实现叫"),s("code",[e._v("VNode")]),e._v(")")]),e._v(" "),s("h2",{attrs:{id:"当前的节点类型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#当前的节点类型"}},[e._v("#")]),e._v(" 当前的节点类型:")]),e._v(" "),s("ul",[s("li",[e._v("jsx: jsx是开发展编写的节点")]),e._v(" "),s("li",[e._v("React Element: jsx经过babel执行jsx方法, 转换为ReactElement")]),e._v(" "),s("li",[e._v("Fiber Node: 介于 React和UI之间, 用于 reconciler 操作的数据结构(虚拟节点)")]),e._v(" "),s("li",[e._v("DOM Element: 宿主环境api最终操作的节点(浏览器)")])]),e._v(" "),s("h2",{attrs:{id:"reconciler工作方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reconciler工作方式"}},[e._v("#")]),e._v(" reconciler工作方式")]),e._v(" "),s("p",[e._v("对于任何一个节点, 核心在于比较节点本身的 ReactElement(存储数据) 和 FiberNode(也要存储数据, 可以数据可以对比)")]),e._v(" "),s("p",[e._v("比较过后会产生一系列"),s("code",[e._v("标记")]),e._v(", 也可以生成"),s("code",[e._v("子FiberNode")])]),e._v(" "),s("p",[e._v("再根据比较的结果生成的不同"),s("code",[e._v("标记")]),e._v("(插入, 更新, 删除, 移动等)去匹配不同宿主环境的API执行")]),e._v(" "),s("ol",[s("li",[e._v("比如挂载"),s("code",[e._v("<div></div>")]),e._v(", 会经过如下过程")])]),e._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 生成ReactElement")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("jsx")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"div"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 对应的FiberNode")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 生成标记(插入标记)")]),e._v("\nPlacement\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br")])]),s("blockquote",[s("p",[e._v("由于标记是 "),s("code",[e._v("Placement")]),e._v(", 也就是执行插入操作, 最终执行插入后, 就将div挂载到了DOM中, 显示在了页面上, 这个挂载操作就完成了")])]),e._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[e._v("将"),s("code",[e._v("<div></div>更新为<p></p>")])])]),e._v(" "),s("p",[e._v("重新执行jsx方法获取p对应的ReactElement, 并且当前的FiberNode是div的FiberNode")]),e._v(" "),s("p",[e._v("div和p比较后, 就会生成新的子FiberNode, 并且获取到当前的标记为 "),s("code",[e._v("Deletion")]),e._v(" 和 "),s("code",[e._v("Placement")])]),e._v(" "),s("p",[e._v("也就是删除div, 插入p, 最终就将视图上的div更新成了p")]),e._v(" "),s("div",{staticClass:"language-js line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// p转换为jsx方法的执行, 获得p对应的 ReactElement")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("jsx")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"p"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 当前FiberNode是div, 也就是更新前的FiberNode")]),e._v("\nFiberNode "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("type"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'div'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 生成子 FiberNode")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// 对应标记")]),e._v("\nDeletion Placement\n")])]),e._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[e._v("1")]),s("br"),s("span",{staticClass:"line-number"},[e._v("2")]),s("br"),s("span",{staticClass:"line-number"},[e._v("3")]),s("br"),s("span",{staticClass:"line-number"},[e._v("4")]),s("br"),s("span",{staticClass:"line-number"},[e._v("5")]),s("br"),s("span",{staticClass:"line-number"},[e._v("6")]),s("br"),s("span",{staticClass:"line-number"},[e._v("7")]),s("br")])]),s("p",[e._v("当所有的ReactElement比较完成后, 就会生成一颗新的FiberNode树, 一共会存在两颗 FiberNode 树:")]),e._v(" "),s("ul",[s("li",[s("code",[e._v("current")]),e._v(": 与视图中真实DOM节点对应的FiberNode树, 这棵树上每个节点称为 "),s("code",[e._v("current fiber")])]),e._v(" "),s("li",[s("code",[e._v("workInProgress")]),e._v(": 触发更新后, 正在reconciler中计算的FiberNode树, 这棵树上每个节点称为 "),s("code",[e._v("workInProgress fiber")])])]),e._v(" "),s("p",[e._v("根据生成的标记执行UI更新, 更新完成后, workInProgress 就会变成 current")]),e._v(" "),s("p",[e._v("所以这两棵树会来回替换, 更新处理过程中, 新的节点都是 workInProgress, 更新完成后, workInProgress 就会变成 current, 如果下一轮触发更新, current也可能会变成 workInProgress")]),e._v(" "),s("p",[e._v("这种来回交替的技术就叫做: "),s("a",{attrs:{href:"https://react.iamkasong.com/process/doubleBuffer.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("双缓冲技术"),s("OutboundLink")],1)]),e._v(" "),s("h2",{attrs:{id:"jsx消费的顺序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jsx消费的顺序"}},[e._v("#")]),e._v(" JSX消费的顺序")]),e._v(" "),s("p",[e._v("在React中, 是以深度优先(DFS)的遍历方式来处理ReactElement")]),e._v(" "),s("ul",[s("li",[e._v("有子节点, 优先处理子节点")]),e._v(" "),s("li",[e._v("没有子节点, 处理兄弟节点")])]),e._v(" "),s("p",[e._v("比如说有一个组件卸载了, 那么它的孙子组件的 unmount执行顺序是什么样子的? 是先子unmount后父unmount")]),e._v(" "),s("p",[e._v("整个过程是一个递归的(Vue一样), 存在 "),s("code",[e._v("递")]),e._v(" 和 "),s("code",[e._v("归")]),e._v("两个阶段")]),e._v(" "),s("ul",[s("li",[e._v("递: 对应beginWork")]),e._v(" "),s("li",[e._v("归: 对应completeWork")])])])}),[],!1,null,null,null);t.default=r.exports}}]);