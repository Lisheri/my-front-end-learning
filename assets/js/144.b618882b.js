(window.webpackJsonp=window.webpackJsonp||[]).push([[144],{811:function(e,v,_){"use strict";_.r(v);var t=_(5),a=Object(t.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"jsx转换"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jsx转换"}},[e._v("#")]),e._v(" JSX转换")]),e._v(" "),_("h2",{attrs:{id:"react项目结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#react项目结构"}},[e._v("#")]),e._v(" React项目结构")]),e._v(" "),_("ul",[_("li",[e._v("react: 宿主环境无关的公用方法")]),e._v(" "),_("li",[e._v("react-reconciler: 协调器的实现, 宿主环境无关")]),e._v(" "),_("li",[e._v("各种宿主环境的包, 比如浏览器环境, 也就是 "),_("code",[e._v("react-dom")]),e._v(", 或者用于测试"),_("code",[e._v("react")]),e._v("环境的包叫做 "),_("code",[e._v("react-noop-renderer")])]),e._v(" "),_("li",[e._v("shared: 公用辅助函数, 宿主环境无关")])]),e._v(" "),_("p",[_("code",[e._v("jsx转换")]),e._v("的逻辑就 位于 "),_("code",[e._v("packages/react")]),e._v(" 中")]),e._v(" "),_("h2",{attrs:{id:"jsx转换是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jsx转换是什么"}},[e._v("#")]),e._v(" JSX转换是什么")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://babeljs.io/repl",target:"_blank",rel:"noopener noreferrer"}},[e._v("babelPlayground中的jsx转换"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("在上述地址中, 在左侧输入一段 "),_("code",[e._v("jsx")]),e._v(" 代码, 就会被编译为右侧 "),_("code",[e._v("React.createElement")]),e._v(" 的调用结果")]),e._v(" "),_("p",[e._v("从 "),_("code",[e._v("jsx")]),e._v(" 代码 编译为 "),_("code",[e._v("createElement")]),e._v(" 函数的过程, 就叫 jsx 转换")]),e._v(" "),_("p",[e._v("调整编译结果后, 还可以编译为 "),_("code",[e._v("jsx()")]),e._v("去执行的方式, 这个方法来源于 "),_("code",[e._v("react/jsx-runtime")])]),e._v(" "),_("p",[e._v("在 React17以前, jsx转换的解雇都是 "),_("code",[e._v("React.createElement")]),e._v(", 而在 17 以后, 转换的结果, 就变成了 "),_("code",[e._v("jsx")]),e._v("这个方法的调用")]),e._v(" "),_("p",[e._v("内部最终调用"),_("code",[e._v("ReactElement")]),e._v("创建vnode")]),e._v(" "),_("h3",{attrs:{id:"包含两部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#包含两部分"}},[e._v("#")]),e._v(" 包含两部分")]),e._v(" "),_("ul",[_("li",[e._v("编译时")]),e._v(" "),_("li",[e._v("运行时: jsx方法或React.createElement 方法的实现(包含 dev, prod两个环境)")])]),e._v(" "),_("p",[e._v("编译时由 babel 编译实现, React内部主要实现运行时, 工作量包含:")]),e._v(" "),_("ul",[_("li",[e._v("实现jsx方法")]),e._v(" "),_("li",[e._v("实现打包流程")]),e._v(" "),_("li",[e._v("实现调试打包结果的环境")])]),e._v(" "),_("h2",{attrs:{id:"实现jsx方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现jsx方法"}},[e._v("#")]),e._v(" 实现jsx方法")]),e._v(" "),_("ol",[_("li",[_("code",[e._v("jsxDEV")])]),e._v(" "),_("li",[_("code",[e._v("jsx")])]),e._v(" "),_("li",[_("code",[e._v("React.createElement")])])]),e._v(" "),_("h2",{attrs:{id:"实现打包流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#实现打包流程"}},[e._v("#")]),e._v(" 实现打包流程")]),e._v(" "),_("p",[e._v("对应上述三种方法, 打包对应的文件")]),e._v(" "),_("ul",[_("li",[_("code",[e._v("react/jsx-dev-runtime.js")]),e._v(" (dev)")]),e._v(" "),_("li",[_("code",[e._v("react/jsx-runtime.js")]),e._v(" (prod)")]),e._v(" "),_("li",[_("code",[e._v("React")])])]),e._v(" "),_("h2",{attrs:{id:"调试打包结果"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#调试打包结果"}},[e._v("#")]),e._v(" 调试打包结果")]),e._v(" "),_("h3",{attrs:{id:"link"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#link"}},[e._v("#")]),e._v(" link")]),e._v(" "),_("p",[e._v("第一种方式是采用 "),_("code",[e._v("link")]),e._v(" 的方式进行调试")]),e._v(" "),_("ol",[_("li",[e._v("使用 "),_("code",[e._v("pnpm link --global")]),e._v(" 将构建产物中的 "),_("code",[e._v("react")]),e._v(" 发布到全局的 "),_("code",[e._v("node_modules")])]),e._v(" "),_("li",[e._v("创建 "),_("code",[e._v("react")]),e._v(" demo 项目")]),e._v(" "),_("li",[e._v("在demo项目中使用 "),_("code",[e._v("pnpm link react --global")]),e._v(", 将依赖的react, 变为刚刚打包的react")])]),e._v(" "),_("blockquote",[_("p",[e._v("优点: 可以模拟实际项目引用 React 的情况\n缺点: 对于目前开发 mini-react 来说, 略显繁琐。对于开发过程, 更加期望的是热更新效果。")])])])}),[],!1,null,null,null);v.default=a.exports}}]);