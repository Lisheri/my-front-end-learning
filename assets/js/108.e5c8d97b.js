(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{641:function(e,t,v){"use strict";v.r(t);var r=v(5),_=Object(r.a)({},(function(){var e=this,t=e.$createElement,v=e._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("h1",{attrs:{id:"vuerouter原理剖析与实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vuerouter原理剖析与实现"}},[e._v("#")]),e._v(" VueRouter原理剖析与实现")]),e._v(" "),v("p",[e._v("此处使用history模式来模拟实现, hash模式主要就是路径是以"),v("code",[e._v("#")]),e._v("开头, 他们的差异很小")]),e._v(" "),v("p",[e._v("需要使用到的一些Vue的知识")]),e._v(" "),v("ul",[v("li",[e._v("插件")]),e._v(" "),v("li",[e._v("混入")]),e._v(" "),v("li",[e._v("Vue.observable()")]),e._v(" "),v("li",[e._v("插槽")]),e._v(" "),v("li",[e._v("render 函数")]),e._v(" "),v("li",[e._v("运行时和完整版的Vue")])]),e._v(" "),v("h2",{attrs:{id:"vuerouter的实现原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vuerouter的实现原理"}},[e._v("#")]),e._v(" VueRouter的实现原理")]),e._v(" "),v("p",[e._v("VueRouter是前端路由, 当路径切换时, 在浏览器端判断当前路径, 并根据路径加载对应的组件")]),e._v(" "),v("h3",{attrs:{id:"hash模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hash模式"}},[e._v("#")]),e._v(" Hash模式")]),e._v(" "),v("ul",[v("li",[e._v("URL 中 # 后面的内容作为路径地址")]),e._v(" "),v("li",[e._v("监听 hashchange事件")]),e._v(" "),v("li",[e._v("根据当前路由地址找到对应组件重新渲染")])]),e._v(" "),v("h3",{attrs:{id:"history模式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#history模式"}},[e._v("#")]),e._v(" History模式")]),e._v(" "),v("ul",[v("li",[e._v("通过 history.pushState() 方法改变地址栏(他仅仅只是改变地址栏, 并把当前地址记录到当前浏览器的记录栈中, 并不会真正跳转到指定路径, 也就是不会发送对应的Get请求)")]),e._v(" "),v("li",[e._v("监听 popstate 事件可以监听到浏览器历史操作的变化, 在 popstate事件的处理函数中, 可以记录改变后的地址(历史记录栈)\n"),v("blockquote",[v("p",[e._v("注: 当调用"),v("code",[e._v("pushState")]),e._v("或者 "),v("code",[e._v("replaceState")]),e._v("并不会触发该事件, 当点击浏览器的前进或后退按钮时, 或者调用"),v("code",[e._v("history")]),e._v("的 "),v("code",[e._v("back")]),e._v("或"),v("code",[e._v("forward")]),e._v("方法时, 该事件才会被触发")])])]),e._v(" "),v("li",[e._v("根据当前路由地址找到对应组件重新渲染")])]),e._v(" "),v("h2",{attrs:{id:"vuerouter-模拟实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vuerouter-模拟实现"}},[e._v("#")]),e._v(" VueRouter 模拟实现")]),e._v(" "),v("p",[e._v("首先必须要有一个注册函数, 因为VueRouter在使用时的第一步是注册插件")]),e._v(" "),v("p",[e._v("Vue功能的强大就在于他的插件机制")]),e._v(" "),v("p",[e._v("因为要创建一个实例, 因此 后续的VueRouter将采用类的方式实现, 并且这个类应该有一个静态的install方法, 因为Vue.use会直接使用VueRouter, 一个类也是一个对象")]),e._v(" "),v("p",[e._v("VueRouter的构造函数, 需要接收一个参数, 里面包含了路由规则, 核心需要记录的就是路由地址和对应的组件")]),e._v(" "),v("p",[e._v("最后需要在Vue实例化时传入创建的 VueRouter实例对象")]),e._v(" "),v("h3",{attrs:{id:"vue-use方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vue-use方法"}},[e._v("#")]),e._v(" Vue.use方法")]),e._v(" "),v("ol",[v("li",[e._v("可以传入函数或者对象\n"),v("ol",[v("li",[e._v("如果传入的是一个函数, Vue.use内部会直接调用该函数")]),e._v(" "),v("li",[e._v("如果是函数, 会调用该对象的install方法")])])]),e._v(" "),v("li",[e._v("这里应该是一个对象, 后续要实现一个install方法")])]),e._v(" "),v("h3",{attrs:{id:"vuerouter-类图"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vuerouter-类图"}},[e._v("#")]),e._v(" VueRouter 类图")]),e._v(" "),v("h2",{attrs:{id:"vurrouter-类名"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vurrouter-类名"}},[e._v("#")]),e._v(" VurRouter (类名)")]),e._v(" "),v("p",[e._v("(属性)")]),e._v(" "),v("ul",[v("li",[e._v("options (路由规则)")]),e._v(" "),v("li",[e._v("data (内有current属性, 记录当前路由地址, data对象是一个响应式对象, 因为current发生变化后, 对应组件需要对应更新, 可以使用Vue.observable)")]),e._v(" "),v("li",[e._v("routeMap (记录路由地址和组件的对应关系)")])]),e._v(" "),v("hr"),e._v(" "),v("p",[e._v("(方法)")]),e._v(" "),v("ul",[v("li",[e._v("Constructor(options): VueRouter; (初始化一系列属性)")]),e._v(" "),v("li",[e._v("_install(Vue): void; (静态方法, 实现vue的插件机制)")]),e._v(" "),v("li",[e._v("init(): void; (主要调用下面三个初始化方法)")]),e._v(" "),v("li",[e._v("initEvent(): void; (用于注册 popState事件, 监听浏览器历史变化)")]),e._v(" "),v("li",[e._v("createRouteMap() void; (初始化 routeMap属性, 将路由规则转换为键值对存储, 键名是路由地址, 键值是对应组件)")]),e._v(" "),v("li",[e._v("initComponents(Vue): void; (创建 routerLink 和 routerView 两个组件)")])])])}),[],!1,null,null,null);t.default=_.exports}}]);